{"version":3,"sources":["angular-1.7.2/angular-animate.js"],"names":[],"mappings":"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","file":"../../angular-1.7.2/angular-animate.js","sourcesContent":["/**\r\n * @license AngularJS v1.7.2\r\n * (c) 2010-2018 Google, Inc. http://angularjs.org\r\n * License: MIT\r\n */\r\n(function (window, angular) {\r\n    'use strict';\r\n\r\n    var ELEMENT_NODE = 1;\r\n    var COMMENT_NODE = 8;\r\n\r\n    var ADD_CLASS_SUFFIX = '-add';\r\n    var REMOVE_CLASS_SUFFIX = '-remove';\r\n    var EVENT_CLASS_PREFIX = 'ng-';\r\n    var ACTIVE_CLASS_SUFFIX = '-active';\r\n    var PREPARE_CLASS_SUFFIX = '-prepare';\r\n\r\n    var NG_ANIMATE_CLASSNAME = 'ng-animate';\r\n    var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\r\n\r\n    // Detect proper transitionend/animationend event names.\r\n    var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\r\n\r\n    // If unprefixed events are not supported but webkit-prefixed are, use the latter.\r\n    // Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\r\n    // Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\r\n    // but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\r\n    // Register both events in case `window.onanimationend` is not supported because of that,\r\n    // do the same for `transitionend` as Safari is likely to exhibit similar behavior.\r\n    // Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\r\n    // therefore there is no reason to test anymore for other vendor prefixes:\r\n    // http://caniuse.com/#search=transition\r\n    if ((window.ontransitionend === undefined) && (window.onwebkittransitionend !== undefined)) {\r\n        CSS_PREFIX = '-webkit-';\r\n        TRANSITION_PROP = 'WebkitTransition';\r\n        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\r\n    } else {\r\n        TRANSITION_PROP = 'transition';\r\n        TRANSITIONEND_EVENT = 'transitionend';\r\n    }\r\n\r\n    if ((window.onanimationend === undefined) && (window.onwebkitanimationend !== undefined)) {\r\n        CSS_PREFIX = '-webkit-';\r\n        ANIMATION_PROP = 'WebkitAnimation';\r\n        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\r\n    } else {\r\n        ANIMATION_PROP = 'animation';\r\n        ANIMATIONEND_EVENT = 'animationend';\r\n    }\r\n\r\n    var DURATION_KEY = 'Duration';\r\n    var PROPERTY_KEY = 'Property';\r\n    var DELAY_KEY = 'Delay';\r\n    var TIMING_KEY = 'TimingFunction';\r\n    var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\r\n    var ANIMATION_PLAYSTATE_KEY = 'PlayState';\r\n    var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\r\n\r\n    var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\r\n    var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\r\n    var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\r\n    var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\r\n\r\n    var ngMinErr = angular.$$minErr('ng');\r\n    function assertArg(arg, name, reason) {\r\n        if (!arg) {\r\n            throw ngMinErr('areq', 'Argument \\'{0}\\' is {1}', (name || '?'), (reason || 'required'));\r\n        }\r\n        return arg;\r\n    }\r\n\r\n    function mergeClasses(a, b) {\r\n        if (!a && !b) return '';\r\n        if (!a) return b;\r\n        if (!b) return a;\r\n        if (isArray(a)) a = a.join(' ');\r\n        if (isArray(b)) b = b.join(' ');\r\n        return a + ' ' + b;\r\n    }\r\n\r\n    function packageStyles(options) {\r\n        var styles = {};\r\n        if (options && (options.to || options.from)) {\r\n            styles.to = options.to;\r\n            styles.from = options.from;\r\n        }\r\n        return styles;\r\n    }\r\n\r\n    function pendClasses(classes, fix, isPrefix) {\r\n        var className = '';\r\n        classes = isArray(classes)\r\n            ? classes\r\n            : classes && isString(classes) && classes.length\r\n                ? classes.split(/\\s+/)\r\n                : [];\r\n        forEach(classes, function (klass, i) {\r\n            if (klass && klass.length > 0) {\r\n                className += (i > 0) ? ' ' : '';\r\n                className += isPrefix ? fix + klass\r\n                                      : klass + fix;\r\n            }\r\n        });\r\n        return className;\r\n    }\r\n\r\n    function removeFromArray(arr, val) {\r\n        var index = arr.indexOf(val);\r\n        if (val >= 0) {\r\n            arr.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    function stripCommentsFromElement(element) {\r\n        if (element instanceof jqLite) {\r\n            switch (element.length) {\r\n                case 0:\r\n                    return element;\r\n\r\n                case 1:\r\n                    // there is no point of stripping anything if the element\r\n                    // is the only element within the jqLite wrapper.\r\n                    // (it's important that we retain the element instance.)\r\n                    if (element[0].nodeType === ELEMENT_NODE) {\r\n                        return element;\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    return jqLite(extractElementNode(element));\r\n            }\r\n        }\r\n\r\n        if (element.nodeType === ELEMENT_NODE) {\r\n            return jqLite(element);\r\n        }\r\n    }\r\n\r\n    function extractElementNode(element) {\r\n        if (!element[0]) return element;\r\n        for (var i = 0; i < element.length; i++) {\r\n            var elm = element[i];\r\n            if (elm.nodeType === ELEMENT_NODE) {\r\n                return elm;\r\n            }\r\n        }\r\n    }\r\n\r\n    function $$addClass($$jqLite, element, className) {\r\n        forEach(element, function (elm) {\r\n            $$jqLite.addClass(elm, className);\r\n        });\r\n    }\r\n\r\n    function $$removeClass($$jqLite, element, className) {\r\n        forEach(element, function (elm) {\r\n            $$jqLite.removeClass(elm, className);\r\n        });\r\n    }\r\n\r\n    function applyAnimationClassesFactory($$jqLite) {\r\n        return function (element, options) {\r\n            if (options.addClass) {\r\n                $$addClass($$jqLite, element, options.addClass);\r\n                options.addClass = null;\r\n            }\r\n            if (options.removeClass) {\r\n                $$removeClass($$jqLite, element, options.removeClass);\r\n                options.removeClass = null;\r\n            }\r\n        };\r\n    }\r\n\r\n    function prepareAnimationOptions(options) {\r\n        options = options || {};\r\n        if (!options.$$prepared) {\r\n            var domOperation = options.domOperation || noop;\r\n            options.domOperation = function () {\r\n                options.$$domOperationFired = true;\r\n                domOperation();\r\n                domOperation = noop;\r\n            };\r\n            options.$$prepared = true;\r\n        }\r\n        return options;\r\n    }\r\n\r\n    function applyAnimationStyles(element, options) {\r\n        applyAnimationFromStyles(element, options);\r\n        applyAnimationToStyles(element, options);\r\n    }\r\n\r\n    function applyAnimationFromStyles(element, options) {\r\n        if (options.from) {\r\n            element.css(options.from);\r\n            options.from = null;\r\n        }\r\n    }\r\n\r\n    function applyAnimationToStyles(element, options) {\r\n        if (options.to) {\r\n            element.css(options.to);\r\n            options.to = null;\r\n        }\r\n    }\r\n\r\n    function mergeAnimationDetails(element, oldAnimation, newAnimation) {\r\n        var target = oldAnimation.options || {};\r\n        var newOptions = newAnimation.options || {};\r\n\r\n        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\r\n        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\r\n        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\r\n\r\n        if (newOptions.preparationClasses) {\r\n            target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\r\n            delete newOptions.preparationClasses;\r\n        }\r\n\r\n        // noop is basically when there is no callback; otherwise something has been set\r\n        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\r\n\r\n        extend(target, newOptions);\r\n\r\n        // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\r\n        if (realDomOperation) {\r\n            target.domOperation = realDomOperation;\r\n        }\r\n\r\n        if (classes.addClass) {\r\n            target.addClass = classes.addClass;\r\n        } else {\r\n            target.addClass = null;\r\n        }\r\n\r\n        if (classes.removeClass) {\r\n            target.removeClass = classes.removeClass;\r\n        } else {\r\n            target.removeClass = null;\r\n        }\r\n\r\n        oldAnimation.addClass = target.addClass;\r\n        oldAnimation.removeClass = target.removeClass;\r\n\r\n        return target;\r\n    }\r\n\r\n    function resolveElementClasses(existing, toAdd, toRemove) {\r\n        var ADD_CLASS = 1;\r\n        var REMOVE_CLASS = -1;\r\n\r\n        var flags = {};\r\n        existing = splitClassesToLookup(existing);\r\n\r\n        toAdd = splitClassesToLookup(toAdd);\r\n        forEach(toAdd, function (value, key) {\r\n            flags[key] = ADD_CLASS;\r\n        });\r\n\r\n        toRemove = splitClassesToLookup(toRemove);\r\n        forEach(toRemove, function (value, key) {\r\n            flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\r\n        });\r\n\r\n        var classes = {\r\n            addClass: '',\r\n            removeClass: ''\r\n        };\r\n\r\n        forEach(flags, function (val, klass) {\r\n            var prop, allow;\r\n            if (val === ADD_CLASS) {\r\n                prop = 'addClass';\r\n                allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];\r\n            } else if (val === REMOVE_CLASS) {\r\n                prop = 'removeClass';\r\n                allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];\r\n            }\r\n            if (allow) {\r\n                if (classes[prop].length) {\r\n                    classes[prop] += ' ';\r\n                }\r\n                classes[prop] += klass;\r\n            }\r\n        });\r\n\r\n        function splitClassesToLookup(classes) {\r\n            if (isString(classes)) {\r\n                classes = classes.split(' ');\r\n            }\r\n\r\n            var obj = {};\r\n            forEach(classes, function (klass) {\r\n                // sometimes the split leaves empty string values\r\n                // incase extra spaces were applied to the options\r\n                if (klass.length) {\r\n                    obj[klass] = true;\r\n                }\r\n            });\r\n            return obj;\r\n        }\r\n\r\n        return classes;\r\n    }\r\n\r\n    function getDomNode(element) {\r\n        return (element instanceof jqLite) ? element[0] : element;\r\n    }\r\n\r\n    function applyGeneratedPreparationClasses(element, event, options) {\r\n        var classes = '';\r\n        if (event) {\r\n            classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\r\n        }\r\n        if (options.addClass) {\r\n            classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\r\n        }\r\n        if (options.removeClass) {\r\n            classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\r\n        }\r\n        if (classes.length) {\r\n            options.preparationClasses = classes;\r\n            element.addClass(classes);\r\n        }\r\n    }\r\n\r\n    function clearGeneratedClasses(element, options) {\r\n        if (options.preparationClasses) {\r\n            element.removeClass(options.preparationClasses);\r\n            options.preparationClasses = null;\r\n        }\r\n        if (options.activeClasses) {\r\n            element.removeClass(options.activeClasses);\r\n            options.activeClasses = null;\r\n        }\r\n    }\r\n\r\n    function blockTransitions(node, duration) {\r\n        // we use a negative delay value since it performs blocking\r\n        // yet it doesn't kill any existing transitions running on the\r\n        // same element which makes this safe for class-based animations\r\n        var value = duration ? '-' + duration + 's' : '';\r\n        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\r\n        return [TRANSITION_DELAY_PROP, value];\r\n    }\r\n\r\n    function blockKeyframeAnimations(node, applyBlock) {\r\n        var value = applyBlock ? 'paused' : '';\r\n        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\r\n        applyInlineStyle(node, [key, value]);\r\n        return [key, value];\r\n    }\r\n\r\n    function applyInlineStyle(node, styleTuple) {\r\n        var prop = styleTuple[0];\r\n        var value = styleTuple[1];\r\n        node.style[prop] = value;\r\n    }\r\n\r\n    function concatWithSpace(a, b) {\r\n        if (!a) return b;\r\n        if (!b) return a;\r\n        return a + ' ' + b;\r\n    }\r\n\r\n    var $$rAFSchedulerFactory = ['$$rAF', function ($$rAF) {\r\n        var queue, cancelFn;\r\n\r\n        function scheduler(tasks) {\r\n            // we make a copy since RAFScheduler mutates the state\r\n            // of the passed in array variable and this would be difficult\r\n            // to track down on the outside code\r\n            queue = queue.concat(tasks);\r\n            nextTick();\r\n        }\r\n\r\n        queue = scheduler.queue = [];\r\n\r\n        /* waitUntilQuiet does two things:\r\n         * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\r\n         * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\r\n         *\r\n         * The motivation here is that animation code can request more time from the scheduler\r\n         * before the next wave runs. This allows for certain DOM properties such as classes to\r\n         * be resolved in time for the next animation to run.\r\n         */\r\n        scheduler.waitUntilQuiet = function (fn) {\r\n            if (cancelFn) cancelFn();\r\n\r\n            cancelFn = $$rAF(function () {\r\n                cancelFn = null;\r\n                fn();\r\n                nextTick();\r\n            });\r\n        };\r\n\r\n        return scheduler;\r\n\r\n        function nextTick() {\r\n            if (!queue.length) return;\r\n\r\n            var items = queue.shift();\r\n            for (var i = 0; i < items.length; i++) {\r\n                items[i]();\r\n            }\r\n\r\n            if (!cancelFn) {\r\n                $$rAF(function () {\r\n                    if (!cancelFn) nextTick();\r\n                });\r\n            }\r\n        }\r\n    }];\r\n\r\n    /**\r\n     * @ngdoc directive\r\n     * @name ngAnimateChildren\r\n     * @restrict AE\r\n     * @element ANY\r\n     *\r\n     * @description\r\n     *\r\n     * ngAnimateChildren allows you to specify that children of this element should animate even if any\r\n     * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\r\n     * (structural) animation, child elements that also have an active structural animation are not animated.\r\n     *\r\n     * Note that even if `ngAnimateChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\r\n     *\r\n     *\r\n     * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\r\n     *     then child animations are allowed. If the value is `false`, child animations are not allowed.\r\n     *\r\n     * @example\r\n     * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\r\n         <file name=\"index.html\">\r\n           <div ng-controller=\"MainController as main\">\r\n             <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\r\n             <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\r\n             <hr>\r\n             <div ng-animate-children=\"{{main.animateChildren}}\">\r\n               <div ng-if=\"main.enterElement\" class=\"container\">\r\n                 List of items:\r\n                 <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\r\n               </div>\r\n             </div>\r\n           </div>\r\n         </file>\r\n         <file name=\"animations.css\">\r\n    \r\n          .container.ng-enter,\r\n          .container.ng-leave {\r\n            transition: all ease 1.5s;\r\n          }\r\n    \r\n          .container.ng-enter,\r\n          .container.ng-leave-active {\r\n            opacity: 0;\r\n          }\r\n    \r\n          .container.ng-leave,\r\n          .container.ng-enter-active {\r\n            opacity: 1;\r\n          }\r\n    \r\n          .item {\r\n            background: firebrick;\r\n            color: #FFF;\r\n            margin-bottom: 10px;\r\n          }\r\n    \r\n          .item.ng-enter,\r\n          .item.ng-leave {\r\n            transition: transform 1.5s ease;\r\n          }\r\n    \r\n          .item.ng-enter {\r\n            transform: translateX(50px);\r\n          }\r\n    \r\n          .item.ng-enter-active {\r\n            transform: translateX(0);\r\n          }\r\n        </file>\r\n        <file name=\"script.js\">\r\n          angular.module('ngAnimateChildren', ['ngAnimate'])\r\n            .controller('MainController', function MainController() {\r\n              this.animateChildren = false;\r\n              this.enterElement = false;\r\n            });\r\n        </file>\r\n      </example>\r\n     */\r\n    var $$AnimateChildrenDirective = ['$interpolate', function ($interpolate) {\r\n        return {\r\n            link: function (scope, element, attrs) {\r\n                var val = attrs.ngAnimateChildren;\r\n                if (isString(val) && val.length === 0) { //empty attribute\r\n                    element.data(NG_ANIMATE_CHILDREN_DATA, true);\r\n                } else {\r\n                    // Interpolate and set the value, so that it is available to\r\n                    // animations that run right after compilation\r\n                    setData($interpolate(val)(scope));\r\n                    attrs.$observe('ngAnimateChildren', setData);\r\n                }\r\n\r\n                function setData(value) {\r\n                    value = value === 'on' || value === 'true';\r\n                    element.data(NG_ANIMATE_CHILDREN_DATA, value);\r\n                }\r\n            }\r\n        };\r\n    }];\r\n\r\n    /* exported $AnimateCssProvider */\r\n\r\n    var ANIMATE_TIMER_KEY = '$$animateCss';\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name $animateCss\r\n     * @kind object\r\n     *\r\n     * @description\r\n     * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\r\n     * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\r\n     * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\r\n     * directives to create more complex animations that can be purely driven using CSS code.\r\n     *\r\n     * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\r\n     * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\r\n     *\r\n     * ## General Use\r\n     * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\r\n     * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\r\n     * any automatic control over cancelling animations and/or preventing animations from being run on\r\n     * child elements will not be handled by AngularJS. For this to work as expected, please use `$animate` to\r\n     * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\r\n     * the CSS animation.\r\n     *\r\n     * The example below shows how we can create a folding animation on an element using `ng-if`:\r\n     *\r\n     * ```html\r\n     * <!-- notice the `fold-animation` CSS class -->\r\n     * <div ng-if=\"onOff\" class=\"fold-animation\">\r\n     *   This element will go BOOM\r\n     * </div>\r\n     * <button ng-click=\"onOff=true\">Fold In</button>\r\n     * ```\r\n     *\r\n     * Now we create the **JavaScript animation** that will trigger the CSS transition:\r\n     *\r\n     * ```js\r\n     * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\r\n     *   return {\r\n     *     enter: function(element, doneFn) {\r\n     *       var height = element[0].offsetHeight;\r\n     *       return $animateCss(element, {\r\n     *         from: { height:'0px' },\r\n     *         to: { height:height + 'px' },\r\n     *         duration: 1 // one second\r\n     *       });\r\n     *     }\r\n     *   }\r\n     * }]);\r\n     * ```\r\n     *\r\n     * ## More Advanced Uses\r\n     *\r\n     * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\r\n     * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\r\n     *\r\n     * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\r\n     * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\r\n     * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\r\n     * to provide a working animation that will run in CSS.\r\n     *\r\n     * The example below showcases a more advanced version of the `.fold-animation` from the example above:\r\n     *\r\n     * ```js\r\n     * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\r\n     *   return {\r\n     *     enter: function(element, doneFn) {\r\n     *       var height = element[0].offsetHeight;\r\n     *       return $animateCss(element, {\r\n     *         addClass: 'red large-text pulse-twice',\r\n     *         easing: 'ease-out',\r\n     *         from: { height:'0px' },\r\n     *         to: { height:height + 'px' },\r\n     *         duration: 1 // one second\r\n     *       });\r\n     *     }\r\n     *   }\r\n     * }]);\r\n     * ```\r\n     *\r\n     * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\r\n     *\r\n     * ```css\r\n     * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\r\n     * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\r\n     * .red { background:red; }\r\n     * .large-text { font-size:20px; }\r\n     *\r\n     * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\r\n     * .pulse-twice {\r\n     *   animation: 0.5s pulse linear 2;\r\n     *   -webkit-animation: 0.5s pulse linear 2;\r\n     * }\r\n     *\r\n     * @keyframes pulse {\r\n     *   from { transform: scale(0.5); }\r\n     *   to { transform: scale(1.5); }\r\n     * }\r\n     *\r\n     * @-webkit-keyframes pulse {\r\n     *   from { -webkit-transform: scale(0.5); }\r\n     *   to { -webkit-transform: scale(1.5); }\r\n     * }\r\n     * ```\r\n     *\r\n     * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\r\n     *\r\n     * ## How the Options are handled\r\n     *\r\n     * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\r\n     * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\r\n     * styles using the `from` and `to` properties.\r\n     *\r\n     * ```js\r\n     * var animator = $animateCss(element, {\r\n     *   from: { background:'red' },\r\n     *   to: { background:'blue' }\r\n     * });\r\n     * animator.start();\r\n     * ```\r\n     *\r\n     * ```css\r\n     * .rotating-animation {\r\n     *   animation:0.5s rotate linear;\r\n     *   -webkit-animation:0.5s rotate linear;\r\n     * }\r\n     *\r\n     * @keyframes rotate {\r\n     *   from { transform: rotate(0deg); }\r\n     *   to { transform: rotate(360deg); }\r\n     * }\r\n     *\r\n     * @-webkit-keyframes rotate {\r\n     *   from { -webkit-transform: rotate(0deg); }\r\n     *   to { -webkit-transform: rotate(360deg); }\r\n     * }\r\n     * ```\r\n     *\r\n     * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\r\n     * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\r\n     * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\r\n     * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\r\n     * and spread across the transition and keyframe animation.\r\n     *\r\n     * ## What is returned\r\n     *\r\n     * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\r\n     * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\r\n     * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\r\n     *\r\n     * ```js\r\n     * var animator = $animateCss(element, { ... });\r\n     * ```\r\n     *\r\n     * Now what do the contents of our `animator` variable look like:\r\n     *\r\n     * ```js\r\n     * {\r\n     *   // starts the animation\r\n     *   start: Function,\r\n     *\r\n     *   // ends (aborts) the animation\r\n     *   end: Function\r\n     * }\r\n     * ```\r\n     *\r\n     * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\r\n     * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\r\n     * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\r\n     * and that changing them will not reconfigure the parameters of the animation.\r\n     *\r\n     * ### runner.done() vs runner.then()\r\n     * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\r\n     * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\r\n     * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\r\n     * unless you really need a digest to kick off afterwards.\r\n     *\r\n     * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\r\n     * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\r\n     * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\r\n     *\r\n     * @param {DOMElement} element the element that will be animated\r\n     * @param {object} options the animation-related options that will be applied during the animation\r\n     *\r\n     * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\r\n     * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\r\n     * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\r\n     * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\r\n     * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\r\n     * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\r\n     * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\r\n     * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\r\n     * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\r\n     * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\r\n     * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\r\n     * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\r\n     * is provided then the animation will be skipped entirely.\r\n     * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\r\n     * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\r\n     * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\r\n     * CSS delay value.\r\n     * * `stagger` - A numeric time value representing the delay between successively animated elements\r\n     * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\r\n     * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\r\n     *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\r\n     * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\r\n     * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\r\n     *    the animation is closed. This is useful for when the styles are used purely for the sake of\r\n     *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\r\n     *    By default this value is set to `false`.\r\n     *\r\n     * @return {object} an object with start and end methods and details about the animation.\r\n     *\r\n     * * `start` - The method to start the animation. This will return a `Promise` when called.\r\n     * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\r\n     */\r\n    var ONE_SECOND = 1000;\r\n\r\n    var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\r\n    var CLOSING_TIME_BUFFER = 1.5;\r\n\r\n    var DETECT_CSS_PROPERTIES = {\r\n        transitionDuration: TRANSITION_DURATION_PROP,\r\n        transitionDelay: TRANSITION_DELAY_PROP,\r\n        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,\r\n        animationDuration: ANIMATION_DURATION_PROP,\r\n        animationDelay: ANIMATION_DELAY_PROP,\r\n        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\r\n    };\r\n\r\n    var DETECT_STAGGER_CSS_PROPERTIES = {\r\n        transitionDuration: TRANSITION_DURATION_PROP,\r\n        transitionDelay: TRANSITION_DELAY_PROP,\r\n        animationDuration: ANIMATION_DURATION_PROP,\r\n        animationDelay: ANIMATION_DELAY_PROP\r\n    };\r\n\r\n    function getCssKeyframeDurationStyle(duration) {\r\n        return [ANIMATION_DURATION_PROP, duration + 's'];\r\n    }\r\n\r\n    function getCssDelayStyle(delay, isKeyframeAnimation) {\r\n        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\r\n        return [prop, delay + 's'];\r\n    }\r\n\r\n    function computeCssStyles($window, element, properties) {\r\n        var styles = Object.create(null);\r\n        var detectedStyles = $window.getComputedStyle(element) || {};\r\n        forEach(properties, function (formalStyleName, actualStyleName) {\r\n            var val = detectedStyles[formalStyleName];\r\n            if (val) {\r\n                var c = val.charAt(0);\r\n\r\n                // only numerical-based values have a negative sign or digit as the first value\r\n                if (c === '-' || c === '+' || c >= 0) {\r\n                    val = parseMaxTime(val);\r\n                }\r\n\r\n                // by setting this to null in the event that the delay is not set or is set directly as 0\r\n                // then we can still allow for negative values to be used later on and not mistake this\r\n                // value for being greater than any other negative value.\r\n                if (val === 0) {\r\n                    val = null;\r\n                }\r\n                styles[actualStyleName] = val;\r\n            }\r\n        });\r\n\r\n        return styles;\r\n    }\r\n\r\n    function parseMaxTime(str) {\r\n        var maxValue = 0;\r\n        var values = str.split(/\\s*,\\s*/);\r\n        forEach(values, function (value) {\r\n            // it's always safe to consider only second values and omit `ms` values since\r\n            // getComputedStyle will always handle the conversion for us\r\n            if (value.charAt(value.length - 1) === 's') {\r\n                value = value.substring(0, value.length - 1);\r\n            }\r\n            value = parseFloat(value) || 0;\r\n            maxValue = maxValue ? Math.max(value, maxValue) : value;\r\n        });\r\n        return maxValue;\r\n    }\r\n\r\n    function truthyTimingValue(val) {\r\n        return val === 0 || val != null;\r\n    }\r\n\r\n    function getCssTransitionDurationStyle(duration, applyOnlyDuration) {\r\n        var style = TRANSITION_PROP;\r\n        var value = duration + 's';\r\n        if (applyOnlyDuration) {\r\n            style += DURATION_KEY;\r\n        } else {\r\n            value += ' linear all';\r\n        }\r\n        return [style, value];\r\n    }\r\n\r\n    function createLocalCacheLookup() {\r\n        var cache = Object.create(null);\r\n        return {\r\n            flush: function () {\r\n                cache = Object.create(null);\r\n            },\r\n\r\n            count: function (key) {\r\n                var entry = cache[key];\r\n                return entry ? entry.total : 0;\r\n            },\r\n\r\n            get: function (key) {\r\n                var entry = cache[key];\r\n                return entry && entry.value;\r\n            },\r\n\r\n            put: function (key, value) {\r\n                if (!cache[key]) {\r\n                    cache[key] = { total: 1, value: value };\r\n                } else {\r\n                    cache[key].total++;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    // we do not reassign an already present style value since\r\n    // if we detect the style property value again we may be\r\n    // detecting styles that were added via the `from` styles.\r\n    // We make use of `isDefined` here since an empty string\r\n    // or null value (which is what getPropertyValue will return\r\n    // for a non-existing style) will still be marked as a valid\r\n    // value for the style (a falsy value implies that the style\r\n    // is to be removed at the end of the animation). If we had a simple\r\n    // \"OR\" statement then it would not be enough to catch that.\r\n    function registerRestorableStyles(backup, node, properties) {\r\n        forEach(properties, function (prop) {\r\n            backup[prop] = isDefined(backup[prop])\r\n                ? backup[prop]\r\n                : node.style.getPropertyValue(prop);\r\n        });\r\n    }\r\n\r\n    var $AnimateCssProvider = ['$animateProvider', /** @this */ function ($animateProvider) {\r\n        var gcsLookup = createLocalCacheLookup();\r\n        var gcsStaggerLookup = createLocalCacheLookup();\r\n\r\n        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\r\n                     '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\r\n             function ($window, $$jqLite, $$AnimateRunner, $timeout,\r\n                      $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {\r\n\r\n                 var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\r\n\r\n                 var parentCounter = 0;\r\n                 function gcsHashFn(node, extraClasses) {\r\n                     var KEY = '$$ngAnimateParentKey';\r\n                     var parentNode = node.parentNode;\r\n                     var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\r\n                     return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\r\n                 }\r\n\r\n                 function computeCachedCssStyles(node, className, cacheKey, properties) {\r\n                     var timings = gcsLookup.get(cacheKey);\r\n\r\n                     if (!timings) {\r\n                         timings = computeCssStyles($window, node, properties);\r\n                         if (timings.animationIterationCount === 'infinite') {\r\n                             timings.animationIterationCount = 1;\r\n                         }\r\n                     }\r\n\r\n                     // we keep putting this in multiple times even though the value and the cacheKey are the same\r\n                     // because we're keeping an internal tally of how many duplicate animations are detected.\r\n                     gcsLookup.put(cacheKey, timings);\r\n                     return timings;\r\n                 }\r\n\r\n                 function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\r\n                     var stagger;\r\n\r\n                     // if we have one or more existing matches of matching elements\r\n                     // containing the same parent + CSS styles (which is how cacheKey works)\r\n                     // then staggering is possible\r\n                     if (gcsLookup.count(cacheKey) > 0) {\r\n                         stagger = gcsStaggerLookup.get(cacheKey);\r\n\r\n                         if (!stagger) {\r\n                             var staggerClassName = pendClasses(className, '-stagger');\r\n\r\n                             $$jqLite.addClass(node, staggerClassName);\r\n\r\n                             stagger = computeCssStyles($window, node, properties);\r\n\r\n                             // force the conversion of a null value to zero incase not set\r\n                             stagger.animationDuration = Math.max(stagger.animationDuration, 0);\r\n                             stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\r\n\r\n                             $$jqLite.removeClass(node, staggerClassName);\r\n\r\n                             gcsStaggerLookup.put(cacheKey, stagger);\r\n                         }\r\n                     }\r\n\r\n                     return stagger || {};\r\n                 }\r\n\r\n                 var rafWaitQueue = [];\r\n                 function waitUntilQuiet(callback) {\r\n                     rafWaitQueue.push(callback);\r\n                     $$rAFScheduler.waitUntilQuiet(function () {\r\n                         gcsLookup.flush();\r\n                         gcsStaggerLookup.flush();\r\n\r\n                         // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\r\n                         // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\r\n                         var pageWidth = $$forceReflow();\r\n\r\n                         // we use a for loop to ensure that if the queue is changed\r\n                         // during this looping then it will consider new requests\r\n                         for (var i = 0; i < rafWaitQueue.length; i++) {\r\n                             rafWaitQueue[i](pageWidth);\r\n                         }\r\n                         rafWaitQueue.length = 0;\r\n                     });\r\n                 }\r\n\r\n                 function computeTimings(node, className, cacheKey) {\r\n                     var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\r\n                     var aD = timings.animationDelay;\r\n                     var tD = timings.transitionDelay;\r\n                     timings.maxDelay = aD && tD\r\n                         ? Math.max(aD, tD)\r\n                         : (aD || tD);\r\n                     timings.maxDuration = Math.max(\r\n                         timings.animationDuration * timings.animationIterationCount,\r\n                         timings.transitionDuration);\r\n\r\n                     return timings;\r\n                 }\r\n\r\n                 return function init(element, initialOptions) {\r\n                     // all of the animation functions should create\r\n                     // a copy of the options data, however, if a\r\n                     // parent service has already created a copy then\r\n                     // we should stick to using that\r\n                     var options = initialOptions || {};\r\n                     if (!options.$$prepared) {\r\n                         options = prepareAnimationOptions(copy(options));\r\n                     }\r\n\r\n                     var restoreStyles = {};\r\n                     var node = getDomNode(element);\r\n                     if (!node\r\n                         || !node.parentNode\r\n                         || !$$animateQueue.enabled()) {\r\n                         return closeAndReturnNoopAnimator();\r\n                     }\r\n\r\n                     var temporaryStyles = [];\r\n                     var classes = element.attr('class');\r\n                     var styles = packageStyles(options);\r\n                     var animationClosed;\r\n                     var animationPaused;\r\n                     var animationCompleted;\r\n                     var runner;\r\n                     var runnerHost;\r\n                     var maxDelay;\r\n                     var maxDelayTime;\r\n                     var maxDuration;\r\n                     var maxDurationTime;\r\n                     var startTime;\r\n                     var events = [];\r\n\r\n                     if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\r\n                         return closeAndReturnNoopAnimator();\r\n                     }\r\n\r\n                     var method = options.event && isArray(options.event)\r\n                           ? options.event.join(' ')\r\n                           : options.event;\r\n\r\n                     var isStructural = method && options.structural;\r\n                     var structuralClassName = '';\r\n                     var addRemoveClassName = '';\r\n\r\n                     if (isStructural) {\r\n                         structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\r\n                     } else if (method) {\r\n                         structuralClassName = method;\r\n                     }\r\n\r\n                     if (options.addClass) {\r\n                         addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\r\n                     }\r\n\r\n                     if (options.removeClass) {\r\n                         if (addRemoveClassName.length) {\r\n                             addRemoveClassName += ' ';\r\n                         }\r\n                         addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\r\n                     }\r\n\r\n                     // there may be a situation where a structural animation is combined together\r\n                     // with CSS classes that need to resolve before the animation is computed.\r\n                     // However this means that there is no explicit CSS code to block the animation\r\n                     // from happening (by setting 0s none in the class name). If this is the case\r\n                     // we need to apply the classes before the first rAF so we know to continue if\r\n                     // there actually is a detected transition or keyframe animation\r\n                     if (options.applyClassesEarly && addRemoveClassName.length) {\r\n                         applyAnimationClasses(element, options);\r\n                     }\r\n\r\n                     var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\r\n                     var fullClassName = classes + ' ' + preparationClasses;\r\n                     var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\r\n                     var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\r\n                     var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\r\n\r\n                     // there is no way we can trigger an animation if no styles and\r\n                     // no classes are being applied which would then trigger a transition,\r\n                     // unless there a is raw keyframe value that is applied to the element.\r\n                     if (!containsKeyframeAnimation\r\n                          && !hasToStyles\r\n                          && !preparationClasses) {\r\n                         return closeAndReturnNoopAnimator();\r\n                     }\r\n\r\n                     var cacheKey, stagger;\r\n                     if (options.stagger > 0) {\r\n                         var staggerVal = parseFloat(options.stagger);\r\n                         stagger = {\r\n                             transitionDelay: staggerVal,\r\n                             animationDelay: staggerVal,\r\n                             transitionDuration: 0,\r\n                             animationDuration: 0\r\n                         };\r\n                     } else {\r\n                         cacheKey = gcsHashFn(node, fullClassName);\r\n                         stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\r\n                     }\r\n\r\n                     if (!options.$$skipPreparationClasses) {\r\n                         $$jqLite.addClass(element, preparationClasses);\r\n                     }\r\n\r\n                     var applyOnlyDuration;\r\n\r\n                     if (options.transitionStyle) {\r\n                         var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\r\n                         applyInlineStyle(node, transitionStyle);\r\n                         temporaryStyles.push(transitionStyle);\r\n                     }\r\n\r\n                     if (options.duration >= 0) {\r\n                         applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\r\n                         var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\r\n\r\n                         // we set the duration so that it will be picked up by getComputedStyle later\r\n                         applyInlineStyle(node, durationStyle);\r\n                         temporaryStyles.push(durationStyle);\r\n                     }\r\n\r\n                     if (options.keyframeStyle) {\r\n                         var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\r\n                         applyInlineStyle(node, keyframeStyle);\r\n                         temporaryStyles.push(keyframeStyle);\r\n                     }\r\n\r\n                     var itemIndex = stagger\r\n                         ? options.staggerIndex >= 0\r\n                             ? options.staggerIndex\r\n                             : gcsLookup.count(cacheKey)\r\n                         : 0;\r\n\r\n                     var isFirst = itemIndex === 0;\r\n\r\n                     // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\r\n                     // without causing any combination of transitions to kick in. By adding a negative delay value\r\n                     // it forces the setup class' transition to end immediately. We later then remove the negative\r\n                     // transition delay to allow for the transition to naturally do it's thing. The beauty here is\r\n                     // that if there is no transition defined then nothing will happen and this will also allow\r\n                     // other transitions to be stacked on top of each other without any chopping them out.\r\n                     if (isFirst && !options.skipBlocking) {\r\n                         blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\r\n                     }\r\n\r\n                     var timings = computeTimings(node, fullClassName, cacheKey);\r\n                     var relativeDelay = timings.maxDelay;\r\n                     maxDelay = Math.max(relativeDelay, 0);\r\n                     maxDuration = timings.maxDuration;\r\n\r\n                     var flags = {};\r\n                     flags.hasTransitions = timings.transitionDuration > 0;\r\n                     flags.hasAnimations = timings.animationDuration > 0;\r\n                     flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty === 'all';\r\n                     flags.applyTransitionDuration = hasToStyles && (\r\n                                                       (flags.hasTransitions && !flags.hasTransitionAll)\r\n                                                        || (flags.hasAnimations && !flags.hasTransitions));\r\n                     flags.applyAnimationDuration = options.duration && flags.hasAnimations;\r\n                     flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\r\n                     flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;\r\n                     flags.recalculateTimingStyles = addRemoveClassName.length > 0;\r\n\r\n                     if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\r\n                         maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\r\n\r\n                         if (flags.applyTransitionDuration) {\r\n                             flags.hasTransitions = true;\r\n                             timings.transitionDuration = maxDuration;\r\n                             applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\r\n                             temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\r\n                         }\r\n\r\n                         if (flags.applyAnimationDuration) {\r\n                             flags.hasAnimations = true;\r\n                             timings.animationDuration = maxDuration;\r\n                             temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\r\n                         }\r\n                     }\r\n\r\n                     if (maxDuration === 0 && !flags.recalculateTimingStyles) {\r\n                         return closeAndReturnNoopAnimator();\r\n                     }\r\n\r\n                     if (options.delay != null) {\r\n                         var delayStyle;\r\n                         if (typeof options.delay !== 'boolean') {\r\n                             delayStyle = parseFloat(options.delay);\r\n                             // number in options.delay means we have to recalculate the delay for the closing timeout\r\n                             maxDelay = Math.max(delayStyle, 0);\r\n                         }\r\n\r\n                         if (flags.applyTransitionDelay) {\r\n                             temporaryStyles.push(getCssDelayStyle(delayStyle));\r\n                         }\r\n\r\n                         if (flags.applyAnimationDelay) {\r\n                             temporaryStyles.push(getCssDelayStyle(delayStyle, true));\r\n                         }\r\n                     }\r\n\r\n                     // we need to recalculate the delay value since we used a pre-emptive negative\r\n                     // delay value and the delay value is required for the final event checking. This\r\n                     // property will ensure that this will happen after the RAF phase has passed.\r\n                     if (options.duration == null && timings.transitionDuration > 0) {\r\n                         flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\r\n                     }\r\n\r\n                     maxDelayTime = maxDelay * ONE_SECOND;\r\n                     maxDurationTime = maxDuration * ONE_SECOND;\r\n                     if (!options.skipBlocking) {\r\n                         flags.blockTransition = timings.transitionDuration > 0;\r\n                         flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\r\n                                                        stagger.animationDelay > 0 &&\r\n                                                        stagger.animationDuration === 0;\r\n                     }\r\n\r\n                     if (options.from) {\r\n                         if (options.cleanupStyles) {\r\n                             registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\r\n                         }\r\n                         applyAnimationFromStyles(element, options);\r\n                     }\r\n\r\n                     if (flags.blockTransition || flags.blockKeyframeAnimation) {\r\n                         applyBlocking(maxDuration);\r\n                     } else if (!options.skipBlocking) {\r\n                         blockTransitions(node, false);\r\n                     }\r\n\r\n                     // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\r\n                     return {\r\n                         $$willAnimate: true,\r\n                         end: endFn,\r\n                         start: function () {\r\n                             if (animationClosed) return;\r\n\r\n                             runnerHost = {\r\n                                 end: endFn,\r\n                                 cancel: cancelFn,\r\n                                 resume: null, //this will be set during the start() phase\r\n                                 pause: null\r\n                             };\r\n\r\n                             runner = new $$AnimateRunner(runnerHost);\r\n\r\n                             waitUntilQuiet(start);\r\n\r\n                             // we don't have access to pause/resume the animation\r\n                             // since it hasn't run yet. AnimateRunner will therefore\r\n                             // set noop functions for resume and pause and they will\r\n                             // later be overridden once the animation is triggered\r\n                             return runner;\r\n                         }\r\n                     };\r\n\r\n                     function endFn() {\r\n                         close();\r\n                     }\r\n\r\n                     function cancelFn() {\r\n                         close(true);\r\n                     }\r\n\r\n                     function close(rejected) {\r\n                         // if the promise has been called already then we shouldn't close\r\n                         // the animation again\r\n                         if (animationClosed || (animationCompleted && animationPaused)) return;\r\n                         animationClosed = true;\r\n                         animationPaused = false;\r\n\r\n                         if (!options.$$skipPreparationClasses) {\r\n                             $$jqLite.removeClass(element, preparationClasses);\r\n                         }\r\n                         $$jqLite.removeClass(element, activeClasses);\r\n\r\n                         blockKeyframeAnimations(node, false);\r\n                         blockTransitions(node, false);\r\n\r\n                         forEach(temporaryStyles, function (entry) {\r\n                             // There is only one way to remove inline style properties entirely from elements.\r\n                             // By using `removeProperty` this works, but we need to convert camel-cased CSS\r\n                             // styles down to hyphenated values.\r\n                             node.style[entry[0]] = '';\r\n                         });\r\n\r\n                         applyAnimationClasses(element, options);\r\n                         applyAnimationStyles(element, options);\r\n\r\n                         if (Object.keys(restoreStyles).length) {\r\n                             forEach(restoreStyles, function (value, prop) {\r\n                                 if (value) {\r\n                                     node.style.setProperty(prop, value);\r\n                                 } else {\r\n                                     node.style.removeProperty(prop);\r\n                                 }\r\n                             });\r\n                         }\r\n\r\n                         // the reason why we have this option is to allow a synchronous closing callback\r\n                         // that is fired as SOON as the animation ends (when the CSS is removed) or if\r\n                         // the animation never takes off at all. A good example is a leave animation since\r\n                         // the element must be removed just after the animation is over or else the element\r\n                         // will appear on screen for one animation frame causing an overbearing flicker.\r\n                         if (options.onDone) {\r\n                             options.onDone();\r\n                         }\r\n\r\n                         if (events && events.length) {\r\n                             // Remove the transitionend / animationend listener(s)\r\n                             element.off(events.join(' '), onAnimationProgress);\r\n                         }\r\n\r\n                         //Cancel the fallback closing timeout and remove the timer data\r\n                         var animationTimerData = element.data(ANIMATE_TIMER_KEY);\r\n                         if (animationTimerData) {\r\n                             $timeout.cancel(animationTimerData[0].timer);\r\n                             element.removeData(ANIMATE_TIMER_KEY);\r\n                         }\r\n\r\n                         // if the preparation function fails then the promise is not setup\r\n                         if (runner) {\r\n                             runner.complete(!rejected);\r\n                         }\r\n                     }\r\n\r\n                     function applyBlocking(duration) {\r\n                         if (flags.blockTransition) {\r\n                             blockTransitions(node, duration);\r\n                         }\r\n\r\n                         if (flags.blockKeyframeAnimation) {\r\n                             blockKeyframeAnimations(node, !!duration);\r\n                         }\r\n                     }\r\n\r\n                     function closeAndReturnNoopAnimator() {\r\n                         runner = new $$AnimateRunner({\r\n                             end: endFn,\r\n                             cancel: cancelFn\r\n                         });\r\n\r\n                         // should flush the cache animation\r\n                         waitUntilQuiet(noop);\r\n                         close();\r\n\r\n                         return {\r\n                             $$willAnimate: false,\r\n                             start: function () {\r\n                                 return runner;\r\n                             },\r\n                             end: endFn\r\n                         };\r\n                     }\r\n\r\n                     function onAnimationProgress(event) {\r\n                         event.stopPropagation();\r\n                         var ev = event.originalEvent || event;\r\n\r\n                         if (ev.target !== node) {\r\n                             // Since TransitionEvent / AnimationEvent bubble up,\r\n                             // we have to ignore events by finished child animations\r\n                             return;\r\n                         }\r\n\r\n                         // we now always use `Date.now()` due to the recent changes with\r\n                         // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\r\n                         var timeStamp = ev.$manualTimeStamp || Date.now();\r\n\r\n                         /* Firefox (or possibly just Gecko) likes to not round values up\r\n                          * when a ms measurement is used for the animation */\r\n                         var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\r\n\r\n                         /* $manualTimeStamp is a mocked timeStamp value which is set\r\n                          * within browserTrigger(). This is only here so that tests can\r\n                          * mock animations properly. Real events fallback to event.timeStamp,\r\n                          * or, if they don't, then a timeStamp is automatically created for them.\r\n                          * We're checking to see if the timeStamp surpasses the expected delay,\r\n                          * but we're using elapsedTime instead of the timeStamp on the 2nd\r\n                          * pre-condition since animationPauseds sometimes close off early */\r\n                         if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\r\n                             // we set this flag to ensure that if the transition is paused then, when resumed,\r\n                             // the animation will automatically close itself since transitions cannot be paused.\r\n                             animationCompleted = true;\r\n                             close();\r\n                         }\r\n                     }\r\n\r\n                     function start() {\r\n                         if (animationClosed) return;\r\n                         if (!node.parentNode) {\r\n                             close();\r\n                             return;\r\n                         }\r\n\r\n                         // even though we only pause keyframe animations here the pause flag\r\n                         // will still happen when transitions are used. Only the transition will\r\n                         // not be paused since that is not possible. If the animation ends when\r\n                         // paused then it will not complete until unpaused or cancelled.\r\n                         var playPause = function (playAnimation) {\r\n                             if (!animationCompleted) {\r\n                                 animationPaused = !playAnimation;\r\n                                 if (timings.animationDuration) {\r\n                                     var value = blockKeyframeAnimations(node, animationPaused);\r\n                                     if (animationPaused) {\r\n                                         temporaryStyles.push(value);\r\n                                     } else {\r\n                                         removeFromArray(temporaryStyles, value);\r\n                                     }\r\n                                 }\r\n                             } else if (animationPaused && playAnimation) {\r\n                                 animationPaused = false;\r\n                                 close();\r\n                             }\r\n                         };\r\n\r\n                         // checking the stagger duration prevents an accidentally cascade of the CSS delay style\r\n                         // being inherited from the parent. If the transition duration is zero then we can safely\r\n                         // rely that the delay value is an intentional stagger delay style.\r\n                         var maxStagger = itemIndex > 0\r\n                                          && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\r\n                                             (timings.animationDuration && stagger.animationDuration === 0))\r\n                                          && Math.max(stagger.animationDelay, stagger.transitionDelay);\r\n                         if (maxStagger) {\r\n                             $timeout(triggerAnimationStart,\r\n                                      Math.floor(maxStagger * itemIndex * ONE_SECOND),\r\n                                      false);\r\n                         } else {\r\n                             triggerAnimationStart();\r\n                         }\r\n\r\n                         // this will decorate the existing promise runner with pause/resume methods\r\n                         runnerHost.resume = function () {\r\n                             playPause(true);\r\n                         };\r\n\r\n                         runnerHost.pause = function () {\r\n                             playPause(false);\r\n                         };\r\n\r\n                         function triggerAnimationStart() {\r\n                             // just incase a stagger animation kicks in when the animation\r\n                             // itself was cancelled entirely\r\n                             if (animationClosed) return;\r\n\r\n                             applyBlocking(false);\r\n\r\n                             forEach(temporaryStyles, function (entry) {\r\n                                 var key = entry[0];\r\n                                 var value = entry[1];\r\n                                 node.style[key] = value;\r\n                             });\r\n\r\n                             applyAnimationClasses(element, options);\r\n                             $$jqLite.addClass(element, activeClasses);\r\n\r\n                             if (flags.recalculateTimingStyles) {\r\n                                 fullClassName = node.getAttribute('class') + ' ' + preparationClasses;\r\n                                 cacheKey = gcsHashFn(node, fullClassName);\r\n\r\n                                 timings = computeTimings(node, fullClassName, cacheKey);\r\n                                 relativeDelay = timings.maxDelay;\r\n                                 maxDelay = Math.max(relativeDelay, 0);\r\n                                 maxDuration = timings.maxDuration;\r\n\r\n                                 if (maxDuration === 0) {\r\n                                     close();\r\n                                     return;\r\n                                 }\r\n\r\n                                 flags.hasTransitions = timings.transitionDuration > 0;\r\n                                 flags.hasAnimations = timings.animationDuration > 0;\r\n                             }\r\n\r\n                             if (flags.applyAnimationDelay) {\r\n                                 relativeDelay = typeof options.delay !== 'boolean' && truthyTimingValue(options.delay)\r\n                                       ? parseFloat(options.delay)\r\n                                       : relativeDelay;\r\n\r\n                                 maxDelay = Math.max(relativeDelay, 0);\r\n                                 timings.animationDelay = relativeDelay;\r\n                                 delayStyle = getCssDelayStyle(relativeDelay, true);\r\n                                 temporaryStyles.push(delayStyle);\r\n                                 node.style[delayStyle[0]] = delayStyle[1];\r\n                             }\r\n\r\n                             maxDelayTime = maxDelay * ONE_SECOND;\r\n                             maxDurationTime = maxDuration * ONE_SECOND;\r\n\r\n                             if (options.easing) {\r\n                                 var easeProp, easeVal = options.easing;\r\n                                 if (flags.hasTransitions) {\r\n                                     easeProp = TRANSITION_PROP + TIMING_KEY;\r\n                                     temporaryStyles.push([easeProp, easeVal]);\r\n                                     node.style[easeProp] = easeVal;\r\n                                 }\r\n                                 if (flags.hasAnimations) {\r\n                                     easeProp = ANIMATION_PROP + TIMING_KEY;\r\n                                     temporaryStyles.push([easeProp, easeVal]);\r\n                                     node.style[easeProp] = easeVal;\r\n                                 }\r\n                             }\r\n\r\n                             if (timings.transitionDuration) {\r\n                                 events.push(TRANSITIONEND_EVENT);\r\n                             }\r\n\r\n                             if (timings.animationDuration) {\r\n                                 events.push(ANIMATIONEND_EVENT);\r\n                             }\r\n\r\n                             startTime = Date.now();\r\n                             var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\r\n                             var endTime = startTime + timerTime;\r\n\r\n                             var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\r\n                             var setupFallbackTimer = true;\r\n                             if (animationsData.length) {\r\n                                 var currentTimerData = animationsData[0];\r\n                                 setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\r\n                                 if (setupFallbackTimer) {\r\n                                     $timeout.cancel(currentTimerData.timer);\r\n                                 } else {\r\n                                     animationsData.push(close);\r\n                                 }\r\n                             }\r\n\r\n                             if (setupFallbackTimer) {\r\n                                 var timer = $timeout(onAnimationExpired, timerTime, false);\r\n                                 animationsData[0] = {\r\n                                     timer: timer,\r\n                                     expectedEndTime: endTime\r\n                                 };\r\n                                 animationsData.push(close);\r\n                                 element.data(ANIMATE_TIMER_KEY, animationsData);\r\n                             }\r\n\r\n                             if (events.length) {\r\n                                 element.on(events.join(' '), onAnimationProgress);\r\n                             }\r\n\r\n                             if (options.to) {\r\n                                 if (options.cleanupStyles) {\r\n                                     registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\r\n                                 }\r\n                                 applyAnimationToStyles(element, options);\r\n                             }\r\n                         }\r\n\r\n                         function onAnimationExpired() {\r\n                             var animationsData = element.data(ANIMATE_TIMER_KEY);\r\n\r\n                             // this will be false in the event that the element was\r\n                             // removed from the DOM (via a leave animation or something\r\n                             // similar)\r\n                             if (animationsData) {\r\n                                 for (var i = 1; i < animationsData.length; i++) {\r\n                                     animationsData[i]();\r\n                                 }\r\n                                 element.removeData(ANIMATE_TIMER_KEY);\r\n                             }\r\n                         }\r\n                     }\r\n                 };\r\n             }];\r\n    }];\r\n\r\n    var $$AnimateCssDriverProvider = ['$$animationProvider', /** @this */ function ($$animationProvider) {\r\n        $$animationProvider.drivers.push('$$animateCssDriver');\r\n\r\n        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\r\n        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\r\n\r\n        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\r\n        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\r\n\r\n        function isDocumentFragment(node) {\r\n            return node.parentNode && node.parentNode.nodeType === 11;\r\n        }\r\n\r\n        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\r\n             function ($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {\r\n\r\n                 // only browsers that support these properties can render animations\r\n                 if (!$sniffer.animations && !$sniffer.transitions) return noop;\r\n\r\n                 var bodyNode = $document[0].body;\r\n                 var rootNode = getDomNode($rootElement);\r\n\r\n                 var rootBodyElement = jqLite(\r\n                   // this is to avoid using something that exists outside of the body\r\n                   // we also special case the doc fragment case because our unit test code\r\n                   // appends the $rootElement to the body after the app has been bootstrapped\r\n                   isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\r\n                 );\r\n\r\n                 return function initDriverFn(animationDetails) {\r\n                     return animationDetails.from && animationDetails.to\r\n                         ? prepareFromToAnchorAnimation(animationDetails.from,\r\n                                                        animationDetails.to,\r\n                                                        animationDetails.classes,\r\n                                                        animationDetails.anchors)\r\n                         : prepareRegularAnimation(animationDetails);\r\n                 };\r\n\r\n                 function filterCssClasses(classes) {\r\n                     //remove all the `ng-` stuff\r\n                     return classes.replace(/\\bng-\\S+\\b/g, '');\r\n                 }\r\n\r\n                 function getUniqueValues(a, b) {\r\n                     if (isString(a)) a = a.split(' ');\r\n                     if (isString(b)) b = b.split(' ');\r\n                     return a.filter(function (val) {\r\n                         return b.indexOf(val) === -1;\r\n                     }).join(' ');\r\n                 }\r\n\r\n                 function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\r\n                     var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\r\n                     var startingClasses = filterCssClasses(getClassVal(clone));\r\n\r\n                     outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\r\n                     inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\r\n\r\n                     clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\r\n\r\n                     rootBodyElement.append(clone);\r\n\r\n                     var animatorIn, animatorOut = prepareOutAnimation();\r\n\r\n                     // the user may not end up using the `out` animation and\r\n                     // only making use of the `in` animation or vice-versa.\r\n                     // In either case we should allow this and not assume the\r\n                     // animation is over unless both animations are not used.\r\n                     if (!animatorOut) {\r\n                         animatorIn = prepareInAnimation();\r\n                         if (!animatorIn) {\r\n                             return end();\r\n                         }\r\n                     }\r\n\r\n                     var startingAnimator = animatorOut || animatorIn;\r\n\r\n                     return {\r\n                         start: function () {\r\n                             var runner;\r\n\r\n                             var currentAnimation = startingAnimator.start();\r\n                             currentAnimation.done(function () {\r\n                                 currentAnimation = null;\r\n                                 if (!animatorIn) {\r\n                                     animatorIn = prepareInAnimation();\r\n                                     if (animatorIn) {\r\n                                         currentAnimation = animatorIn.start();\r\n                                         currentAnimation.done(function () {\r\n                                             currentAnimation = null;\r\n                                             end();\r\n                                             runner.complete();\r\n                                         });\r\n                                         return currentAnimation;\r\n                                     }\r\n                                 }\r\n                                 // in the event that there is no `in` animation\r\n                                 end();\r\n                                 runner.complete();\r\n                             });\r\n\r\n                             runner = new $$AnimateRunner({\r\n                                 end: endFn,\r\n                                 cancel: endFn\r\n                             });\r\n\r\n                             return runner;\r\n\r\n                             function endFn() {\r\n                                 if (currentAnimation) {\r\n                                     currentAnimation.end();\r\n                                 }\r\n                             }\r\n                         }\r\n                     };\r\n\r\n                     function calculateAnchorStyles(anchor) {\r\n                         var styles = {};\r\n\r\n                         var coords = getDomNode(anchor).getBoundingClientRect();\r\n\r\n                         // we iterate directly since safari messes up and doesn't return\r\n                         // all the keys for the coords object when iterated\r\n                         forEach(['width', 'height', 'top', 'left'], function (key) {\r\n                             var value = coords[key];\r\n                             switch (key) {\r\n                                 case 'top':\r\n                                     value += bodyNode.scrollTop;\r\n                                     break;\r\n                                 case 'left':\r\n                                     value += bodyNode.scrollLeft;\r\n                                     break;\r\n                             }\r\n                             styles[key] = Math.floor(value) + 'px';\r\n                         });\r\n                         return styles;\r\n                     }\r\n\r\n                     function prepareOutAnimation() {\r\n                         var animator = $animateCss(clone, {\r\n                             addClass: NG_OUT_ANCHOR_CLASS_NAME,\r\n                             delay: true,\r\n                             from: calculateAnchorStyles(outAnchor)\r\n                         });\r\n\r\n                         // read the comment within `prepareRegularAnimation` to understand\r\n                         // why this check is necessary\r\n                         return animator.$$willAnimate ? animator : null;\r\n                     }\r\n\r\n                     function getClassVal(element) {\r\n                         return element.attr('class') || '';\r\n                     }\r\n\r\n                     function prepareInAnimation() {\r\n                         var endingClasses = filterCssClasses(getClassVal(inAnchor));\r\n                         var toAdd = getUniqueValues(endingClasses, startingClasses);\r\n                         var toRemove = getUniqueValues(startingClasses, endingClasses);\r\n\r\n                         var animator = $animateCss(clone, {\r\n                             to: calculateAnchorStyles(inAnchor),\r\n                             addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\r\n                             removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\r\n                             delay: true\r\n                         });\r\n\r\n                         // read the comment within `prepareRegularAnimation` to understand\r\n                         // why this check is necessary\r\n                         return animator.$$willAnimate ? animator : null;\r\n                     }\r\n\r\n                     function end() {\r\n                         clone.remove();\r\n                         outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\r\n                         inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\r\n                     }\r\n                 }\r\n\r\n                 function prepareFromToAnchorAnimation(from, to, classes, anchors) {\r\n                     var fromAnimation = prepareRegularAnimation(from, noop);\r\n                     var toAnimation = prepareRegularAnimation(to, noop);\r\n\r\n                     var anchorAnimations = [];\r\n                     forEach(anchors, function (anchor) {\r\n                         var outElement = anchor['out'];\r\n                         var inElement = anchor['in'];\r\n                         var animator = prepareAnchoredAnimation(classes, outElement, inElement);\r\n                         if (animator) {\r\n                             anchorAnimations.push(animator);\r\n                         }\r\n                     });\r\n\r\n                     // no point in doing anything when there are no elements to animate\r\n                     if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\r\n\r\n                     return {\r\n                         start: function () {\r\n                             var animationRunners = [];\r\n\r\n                             if (fromAnimation) {\r\n                                 animationRunners.push(fromAnimation.start());\r\n                             }\r\n\r\n                             if (toAnimation) {\r\n                                 animationRunners.push(toAnimation.start());\r\n                             }\r\n\r\n                             forEach(anchorAnimations, function (animation) {\r\n                                 animationRunners.push(animation.start());\r\n                             });\r\n\r\n                             var runner = new $$AnimateRunner({\r\n                                 end: endFn,\r\n                                 cancel: endFn // CSS-driven animations cannot be cancelled, only ended\r\n                             });\r\n\r\n                             $$AnimateRunner.all(animationRunners, function (status) {\r\n                                 runner.complete(status);\r\n                             });\r\n\r\n                             return runner;\r\n\r\n                             function endFn() {\r\n                                 forEach(animationRunners, function (runner) {\r\n                                     runner.end();\r\n                                 });\r\n                             }\r\n                         }\r\n                     };\r\n                 }\r\n\r\n                 function prepareRegularAnimation(animationDetails) {\r\n                     var element = animationDetails.element;\r\n                     var options = animationDetails.options || {};\r\n\r\n                     if (animationDetails.structural) {\r\n                         options.event = animationDetails.event;\r\n                         options.structural = true;\r\n                         options.applyClassesEarly = true;\r\n\r\n                         // we special case the leave animation since we want to ensure that\r\n                         // the element is removed as soon as the animation is over. Otherwise\r\n                         // a flicker might appear or the element may not be removed at all\r\n                         if (animationDetails.event === 'leave') {\r\n                             options.onDone = options.domOperation;\r\n                         }\r\n                     }\r\n\r\n                     // We assign the preparationClasses as the actual animation event since\r\n                     // the internals of $animateCss will just suffix the event token values\r\n                     // with `-active` to trigger the animation.\r\n                     if (options.preparationClasses) {\r\n                         options.event = concatWithSpace(options.event, options.preparationClasses);\r\n                     }\r\n\r\n                     var animator = $animateCss(element, options);\r\n\r\n                     // the driver lookup code inside of $$animation attempts to spawn a\r\n                     // driver one by one until a driver returns a.$$willAnimate animator object.\r\n                     // $animateCss will always return an object, however, it will pass in\r\n                     // a flag as a hint as to whether an animation was detected or not\r\n                     return animator.$$willAnimate ? animator : null;\r\n                 }\r\n             }];\r\n    }];\r\n\r\n    // TODO(matsko): use caching here to speed things up for detection\r\n    // TODO(matsko): add documentation\r\n    //  by the time...\r\n\r\n    var $$AnimateJsProvider = ['$animateProvider', /** @this */ function ($animateProvider) {\r\n        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\r\n             function ($injector, $$AnimateRunner, $$jqLite) {\r\n\r\n                 var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\r\n                 // $animateJs(element, 'enter');\r\n                 return function (element, event, classes, options) {\r\n                     var animationClosed = false;\r\n\r\n                     // the `classes` argument is optional and if it is not used\r\n                     // then the classes will be resolved from the element's className\r\n                     // property as well as options.addClass/options.removeClass.\r\n                     if (arguments.length === 3 && isObject(classes)) {\r\n                         options = classes;\r\n                         classes = null;\r\n                     }\r\n\r\n                     options = prepareAnimationOptions(options);\r\n                     if (!classes) {\r\n                         classes = element.attr('class') || '';\r\n                         if (options.addClass) {\r\n                             classes += ' ' + options.addClass;\r\n                         }\r\n                         if (options.removeClass) {\r\n                             classes += ' ' + options.removeClass;\r\n                         }\r\n                     }\r\n\r\n                     var classesToAdd = options.addClass;\r\n                     var classesToRemove = options.removeClass;\r\n\r\n                     // the lookupAnimations function returns a series of animation objects that are\r\n                     // matched up with one or more of the CSS classes. These animation objects are\r\n                     // defined via the module.animation factory function. If nothing is detected then\r\n                     // we don't return anything which then makes $animation query the next driver.\r\n                     var animations = lookupAnimations(classes);\r\n                     var before, after;\r\n                     if (animations.length) {\r\n                         var afterFn, beforeFn;\r\n                         if (event === 'leave') {\r\n                             beforeFn = 'leave';\r\n                             afterFn = 'afterLeave'; // TODO(matsko): get rid of this\r\n                         } else {\r\n                             beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\r\n                             afterFn = event;\r\n                         }\r\n\r\n                         if (event !== 'enter' && event !== 'move') {\r\n                             before = packageAnimations(element, event, options, animations, beforeFn);\r\n                         }\r\n                         after = packageAnimations(element, event, options, animations, afterFn);\r\n                     }\r\n\r\n                     // no matching animations\r\n                     if (!before && !after) return;\r\n\r\n                     function applyOptions() {\r\n                         options.domOperation();\r\n                         applyAnimationClasses(element, options);\r\n                     }\r\n\r\n                     function close() {\r\n                         animationClosed = true;\r\n                         applyOptions();\r\n                         applyAnimationStyles(element, options);\r\n                     }\r\n\r\n                     var runner;\r\n\r\n                     return {\r\n                         $$willAnimate: true,\r\n                         end: function () {\r\n                             if (runner) {\r\n                                 runner.end();\r\n                             } else {\r\n                                 close();\r\n                                 runner = new $$AnimateRunner();\r\n                                 runner.complete(true);\r\n                             }\r\n                             return runner;\r\n                         },\r\n                         start: function () {\r\n                             if (runner) {\r\n                                 return runner;\r\n                             }\r\n\r\n                             runner = new $$AnimateRunner();\r\n                             var closeActiveAnimations;\r\n                             var chain = [];\r\n\r\n                             if (before) {\r\n                                 chain.push(function (fn) {\r\n                                     closeActiveAnimations = before(fn);\r\n                                 });\r\n                             }\r\n\r\n                             if (chain.length) {\r\n                                 chain.push(function (fn) {\r\n                                     applyOptions();\r\n                                     fn(true);\r\n                                 });\r\n                             } else {\r\n                                 applyOptions();\r\n                             }\r\n\r\n                             if (after) {\r\n                                 chain.push(function (fn) {\r\n                                     closeActiveAnimations = after(fn);\r\n                                 });\r\n                             }\r\n\r\n                             runner.setHost({\r\n                                 end: function () {\r\n                                     endAnimations();\r\n                                 },\r\n                                 cancel: function () {\r\n                                     endAnimations(true);\r\n                                 }\r\n                             });\r\n\r\n                             $$AnimateRunner.chain(chain, onComplete);\r\n                             return runner;\r\n\r\n                             function onComplete(success) {\r\n                                 close(success);\r\n                                 runner.complete(success);\r\n                             }\r\n\r\n                             function endAnimations(cancelled) {\r\n                                 if (!animationClosed) {\r\n                                     (closeActiveAnimations || noop)(cancelled);\r\n                                     onComplete(cancelled);\r\n                                 }\r\n                             }\r\n                         }\r\n                     };\r\n\r\n                     function executeAnimationFn(fn, element, event, options, onDone) {\r\n                         var args;\r\n                         switch (event) {\r\n                             case 'animate':\r\n                                 args = [element, options.from, options.to, onDone];\r\n                                 break;\r\n\r\n                             case 'setClass':\r\n                                 args = [element, classesToAdd, classesToRemove, onDone];\r\n                                 break;\r\n\r\n                             case 'addClass':\r\n                                 args = [element, classesToAdd, onDone];\r\n                                 break;\r\n\r\n                             case 'removeClass':\r\n                                 args = [element, classesToRemove, onDone];\r\n                                 break;\r\n\r\n                             default:\r\n                                 args = [element, onDone];\r\n                                 break;\r\n                         }\r\n\r\n                         args.push(options);\r\n\r\n                         var value = fn.apply(fn, args);\r\n                         if (value) {\r\n                             if (isFunction(value.start)) {\r\n                                 value = value.start();\r\n                             }\r\n\r\n                             if (value instanceof $$AnimateRunner) {\r\n                                 value.done(onDone);\r\n                             } else if (isFunction(value)) {\r\n                                 // optional onEnd / onCancel callback\r\n                                 return value;\r\n                             }\r\n                         }\r\n\r\n                         return noop;\r\n                     }\r\n\r\n                     function groupEventedAnimations(element, event, options, animations, fnName) {\r\n                         var operations = [];\r\n                         forEach(animations, function (ani) {\r\n                             var animation = ani[fnName];\r\n                             if (!animation) return;\r\n\r\n                             // note that all of these animations will run in parallel\r\n                             operations.push(function () {\r\n                                 var runner;\r\n                                 var endProgressCb;\r\n\r\n                                 var resolved = false;\r\n                                 var onAnimationComplete = function (rejected) {\r\n                                     if (!resolved) {\r\n                                         resolved = true;\r\n                                         (endProgressCb || noop)(rejected);\r\n                                         runner.complete(!rejected);\r\n                                     }\r\n                                 };\r\n\r\n                                 runner = new $$AnimateRunner({\r\n                                     end: function () {\r\n                                         onAnimationComplete();\r\n                                     },\r\n                                     cancel: function () {\r\n                                         onAnimationComplete(true);\r\n                                     }\r\n                                 });\r\n\r\n                                 endProgressCb = executeAnimationFn(animation, element, event, options, function (result) {\r\n                                     var cancelled = result === false;\r\n                                     onAnimationComplete(cancelled);\r\n                                 });\r\n\r\n                                 return runner;\r\n                             });\r\n                         });\r\n\r\n                         return operations;\r\n                     }\r\n\r\n                     function packageAnimations(element, event, options, animations, fnName) {\r\n                         var operations = groupEventedAnimations(element, event, options, animations, fnName);\r\n                         if (operations.length === 0) {\r\n                             var a, b;\r\n                             if (fnName === 'beforeSetClass') {\r\n                                 a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\r\n                                 b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\r\n                             } else if (fnName === 'setClass') {\r\n                                 a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\r\n                                 b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\r\n                             }\r\n\r\n                             if (a) {\r\n                                 operations = operations.concat(a);\r\n                             }\r\n                             if (b) {\r\n                                 operations = operations.concat(b);\r\n                             }\r\n                         }\r\n\r\n                         if (operations.length === 0) return;\r\n\r\n                         // TODO(matsko): add documentation\r\n                         return function startAnimation(callback) {\r\n                             var runners = [];\r\n                             if (operations.length) {\r\n                                 forEach(operations, function (animateFn) {\r\n                                     runners.push(animateFn());\r\n                                 });\r\n                             }\r\n\r\n                             if (runners.length) {\r\n                                 $$AnimateRunner.all(runners, callback);\r\n                             } else {\r\n                                 callback();\r\n                             }\r\n\r\n                             return function endFn(reject) {\r\n                                 forEach(runners, function (runner) {\r\n                                     if (reject) {\r\n                                         runner.cancel();\r\n                                     } else {\r\n                                         runner.end();\r\n                                     }\r\n                                 });\r\n                             };\r\n                         };\r\n                     }\r\n                 };\r\n\r\n                 function lookupAnimations(classes) {\r\n                     classes = isArray(classes) ? classes : classes.split(' ');\r\n                     var matches = [], flagMap = {};\r\n                     for (var i = 0; i < classes.length; i++) {\r\n                         var klass = classes[i],\r\n                             animationFactory = $animateProvider.$$registeredAnimations[klass];\r\n                         if (animationFactory && !flagMap[klass]) {\r\n                             matches.push($injector.get(animationFactory));\r\n                             flagMap[klass] = true;\r\n                         }\r\n                     }\r\n                     return matches;\r\n                 }\r\n             }];\r\n    }];\r\n\r\n    var $$AnimateJsDriverProvider = ['$$animationProvider', /** @this */ function ($$animationProvider) {\r\n        $$animationProvider.drivers.push('$$animateJsDriver');\r\n        this.$get = ['$$animateJs', '$$AnimateRunner', function ($$animateJs, $$AnimateRunner) {\r\n            return function initDriverFn(animationDetails) {\r\n                if (animationDetails.from && animationDetails.to) {\r\n                    var fromAnimation = prepareAnimation(animationDetails.from);\r\n                    var toAnimation = prepareAnimation(animationDetails.to);\r\n                    if (!fromAnimation && !toAnimation) return;\r\n\r\n                    return {\r\n                        start: function () {\r\n                            var animationRunners = [];\r\n\r\n                            if (fromAnimation) {\r\n                                animationRunners.push(fromAnimation.start());\r\n                            }\r\n\r\n                            if (toAnimation) {\r\n                                animationRunners.push(toAnimation.start());\r\n                            }\r\n\r\n                            $$AnimateRunner.all(animationRunners, done);\r\n\r\n                            var runner = new $$AnimateRunner({\r\n                                end: endFnFactory(),\r\n                                cancel: endFnFactory()\r\n                            });\r\n\r\n                            return runner;\r\n\r\n                            function endFnFactory() {\r\n                                return function () {\r\n                                    forEach(animationRunners, function (runner) {\r\n                                        // at this point we cannot cancel animations for groups just yet. 1.5+\r\n                                        runner.end();\r\n                                    });\r\n                                };\r\n                            }\r\n\r\n                            function done(status) {\r\n                                runner.complete(status);\r\n                            }\r\n                        }\r\n                    };\r\n                } else {\r\n                    return prepareAnimation(animationDetails);\r\n                }\r\n            };\r\n\r\n            function prepareAnimation(animationDetails) {\r\n                // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\r\n                var element = animationDetails.element;\r\n                var event = animationDetails.event;\r\n                var options = animationDetails.options;\r\n                var classes = animationDetails.classes;\r\n                return $$animateJs(element, event, classes, options);\r\n            }\r\n        }];\r\n    }];\r\n\r\n    var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\r\n    var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\r\n    var $$AnimateQueueProvider = ['$animateProvider', /** @this */ function ($animateProvider) {\r\n        var PRE_DIGEST_STATE = 1;\r\n        var RUNNING_STATE = 2;\r\n        var ONE_SPACE = ' ';\r\n\r\n        var rules = this.rules = {\r\n            skip: [],\r\n            cancel: [],\r\n            join: []\r\n        };\r\n\r\n        function makeTruthyCssClassMap(classString) {\r\n            if (!classString) {\r\n                return null;\r\n            }\r\n\r\n            var keys = classString.split(ONE_SPACE);\r\n            var map = Object.create(null);\r\n\r\n            forEach(keys, function (key) {\r\n                map[key] = true;\r\n            });\r\n            return map;\r\n        }\r\n\r\n        function hasMatchingClasses(newClassString, currentClassString) {\r\n            if (newClassString && currentClassString) {\r\n                var currentClassMap = makeTruthyCssClassMap(currentClassString);\r\n                return newClassString.split(ONE_SPACE).some(function (className) {\r\n                    return currentClassMap[className];\r\n                });\r\n            }\r\n        }\r\n\r\n        function isAllowed(ruleType, currentAnimation, previousAnimation) {\r\n            return rules[ruleType].some(function (fn) {\r\n                return fn(currentAnimation, previousAnimation);\r\n            });\r\n        }\r\n\r\n        function hasAnimationClasses(animation, and) {\r\n            var a = (animation.addClass || '').length > 0;\r\n            var b = (animation.removeClass || '').length > 0;\r\n            return and ? a && b : a || b;\r\n        }\r\n\r\n        rules.join.push(function (newAnimation, currentAnimation) {\r\n            // if the new animation is class-based then we can just tack that on\r\n            return !newAnimation.structural && hasAnimationClasses(newAnimation);\r\n        });\r\n\r\n        rules.skip.push(function (newAnimation, currentAnimation) {\r\n            // there is no need to animate anything if no classes are being added and\r\n            // there is no structural animation that will be triggered\r\n            return !newAnimation.structural && !hasAnimationClasses(newAnimation);\r\n        });\r\n\r\n        rules.skip.push(function (newAnimation, currentAnimation) {\r\n            // why should we trigger a new structural animation if the element will\r\n            // be removed from the DOM anyway?\r\n            return currentAnimation.event === 'leave' && newAnimation.structural;\r\n        });\r\n\r\n        rules.skip.push(function (newAnimation, currentAnimation) {\r\n            // if there is an ongoing current animation then don't even bother running the class-based animation\r\n            return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\r\n        });\r\n\r\n        rules.cancel.push(function (newAnimation, currentAnimation) {\r\n            // there can never be two structural animations running at the same time\r\n            return currentAnimation.structural && newAnimation.structural;\r\n        });\r\n\r\n        rules.cancel.push(function (newAnimation, currentAnimation) {\r\n            // if the previous animation is already running, but the new animation will\r\n            // be triggered, but the new animation is structural\r\n            return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\r\n        });\r\n\r\n        rules.cancel.push(function (newAnimation, currentAnimation) {\r\n            // cancel the animation if classes added / removed in both animation cancel each other out,\r\n            // but only if the current animation isn't structural\r\n\r\n            if (currentAnimation.structural) return false;\r\n\r\n            var nA = newAnimation.addClass;\r\n            var nR = newAnimation.removeClass;\r\n            var cA = currentAnimation.addClass;\r\n            var cR = currentAnimation.removeClass;\r\n\r\n            // early detection to save the global CPU shortage :)\r\n            if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\r\n                return false;\r\n            }\r\n\r\n            return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\r\n        });\r\n\r\n        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$Map',\r\n                     '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\r\n                     '$$isDocumentHidden',\r\n             function ($$rAF, $rootScope, $rootElement, $document, $$Map,\r\n                      $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow,\r\n                      $$isDocumentHidden) {\r\n\r\n                 var activeAnimationsLookup = new $$Map();\r\n                 var disabledElementsLookup = new $$Map();\r\n                 var animationsEnabled = null;\r\n\r\n                 function postDigestTaskFactory() {\r\n                     var postDigestCalled = false;\r\n                     return function (fn) {\r\n                         // we only issue a call to postDigest before\r\n                         // it has first passed. This prevents any callbacks\r\n                         // from not firing once the animation has completed\r\n                         // since it will be out of the digest cycle.\r\n                         if (postDigestCalled) {\r\n                             fn();\r\n                         } else {\r\n                             $rootScope.$$postDigest(function () {\r\n                                 postDigestCalled = true;\r\n                                 fn();\r\n                             });\r\n                         }\r\n                     };\r\n                 }\r\n\r\n                 // Wait until all directive and route-related templates are downloaded and\r\n                 // compiled. The $templateRequest.totalPendingRequests variable keeps track of\r\n                 // all of the remote templates being currently downloaded. If there are no\r\n                 // templates currently downloading then the watcher will still fire anyway.\r\n                 var deregisterWatch = $rootScope.$watch(\r\n                   function () { return $templateRequest.totalPendingRequests === 0; },\r\n                   function (isEmpty) {\r\n                       if (!isEmpty) return;\r\n                       deregisterWatch();\r\n\r\n                       // Now that all templates have been downloaded, $animate will wait until\r\n                       // the post digest queue is empty before enabling animations. By having two\r\n                       // calls to $postDigest calls we can ensure that the flag is enabled at the\r\n                       // very end of the post digest queue. Since all of the animations in $animate\r\n                       // use $postDigest, it's important that the code below executes at the end.\r\n                       // This basically means that the page is fully downloaded and compiled before\r\n                       // any animations are triggered.\r\n                       $rootScope.$$postDigest(function () {\r\n                           $rootScope.$$postDigest(function () {\r\n                               // we check for null directly in the event that the application already called\r\n                               // .enabled() with whatever arguments that it provided it with\r\n                               if (animationsEnabled === null) {\r\n                                   animationsEnabled = true;\r\n                               }\r\n                           });\r\n                       });\r\n                   }\r\n                 );\r\n\r\n                 var callbackRegistry = Object.create(null);\r\n\r\n                 // remember that the `customFilter`/`classNameFilter` are set during the\r\n                 // provider/config stage therefore we can optimize here and setup helper functions\r\n                 var customFilter = $animateProvider.customFilter();\r\n                 var classNameFilter = $animateProvider.classNameFilter();\r\n                 var returnTrue = function () { return true; };\r\n\r\n                 var isAnimatableByFilter = customFilter || returnTrue;\r\n                 var isAnimatableClassName = !classNameFilter ? returnTrue : function (node, options) {\r\n                     var className = [node.getAttribute('class'), options.addClass, options.removeClass].join(' ');\r\n                     return classNameFilter.test(className);\r\n                 };\r\n\r\n                 var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\r\n\r\n                 function normalizeAnimationDetails(element, animation) {\r\n                     return mergeAnimationDetails(element, animation, {});\r\n                 }\r\n\r\n                 // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\r\n                 var contains = window.Node.prototype.contains || /** @this */ function (arg) {\r\n                     // eslint-disable-next-line no-bitwise\r\n                     return this === arg || !!(this.compareDocumentPosition(arg) & 16);\r\n                 };\r\n\r\n                 function findCallbacks(targetParentNode, targetNode, event) {\r\n                     var matches = [];\r\n                     var entries = callbackRegistry[event];\r\n                     if (entries) {\r\n                         forEach(entries, function (entry) {\r\n                             if (contains.call(entry.node, targetNode)) {\r\n                                 matches.push(entry.callback);\r\n                             } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\r\n                                 matches.push(entry.callback);\r\n                             }\r\n                         });\r\n                     }\r\n\r\n                     return matches;\r\n                 }\r\n\r\n                 function filterFromRegistry(list, matchContainer, matchCallback) {\r\n                     var containerNode = extractElementNode(matchContainer);\r\n                     return list.filter(function (entry) {\r\n                         var isMatch = entry.node === containerNode &&\r\n                                         (!matchCallback || entry.callback === matchCallback);\r\n                         return !isMatch;\r\n                     });\r\n                 }\r\n\r\n                 function cleanupEventListeners(phase, node) {\r\n                     if (phase === 'close' && !node.parentNode) {\r\n                         // If the element is not attached to a parentNode, it has been removed by\r\n                         // the domOperation, and we can safely remove the event callbacks\r\n                         $animate.off(node);\r\n                     }\r\n                 }\r\n\r\n                 var $animate = {\r\n                     on: function (event, container, callback) {\r\n                         var node = extractElementNode(container);\r\n                         callbackRegistry[event] = callbackRegistry[event] || [];\r\n                         callbackRegistry[event].push({\r\n                             node: node,\r\n                             callback: callback\r\n                         });\r\n\r\n                         // Remove the callback when the element is removed from the DOM\r\n                         jqLite(container).on('$destroy', function () {\r\n                             var animationDetails = activeAnimationsLookup.get(node);\r\n\r\n                             if (!animationDetails) {\r\n                                 // If there's an animation ongoing, the callback calling code will remove\r\n                                 // the event listeners. If we'd remove here, the callbacks would be removed\r\n                                 // before the animation ends\r\n                                 $animate.off(event, container, callback);\r\n                             }\r\n                         });\r\n                     },\r\n\r\n                     off: function (event, container, callback) {\r\n                         if (arguments.length === 1 && !isString(arguments[0])) {\r\n                             container = arguments[0];\r\n                             for (var eventType in callbackRegistry) {\r\n                                 callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\r\n                             }\r\n\r\n                             return;\r\n                         }\r\n\r\n                         var entries = callbackRegistry[event];\r\n                         if (!entries) return;\r\n\r\n                         callbackRegistry[event] = arguments.length === 1\r\n                             ? null\r\n                             : filterFromRegistry(entries, container, callback);\r\n                     },\r\n\r\n                     pin: function (element, parentElement) {\r\n                         assertArg(isElement(element), 'element', 'not an element');\r\n                         assertArg(isElement(parentElement), 'parentElement', 'not an element');\r\n                         element.data(NG_ANIMATE_PIN_DATA, parentElement);\r\n                     },\r\n\r\n                     push: function (element, event, options, domOperation) {\r\n                         options = options || {};\r\n                         options.domOperation = domOperation;\r\n                         return queueAnimation(element, event, options);\r\n                     },\r\n\r\n                     // this method has four signatures:\r\n                     //  () - global getter\r\n                     //  (bool) - global setter\r\n                     //  (element) - element getter\r\n                     //  (element, bool) - element setter<F37>\r\n                     enabled: function (element, bool) {\r\n                         var argCount = arguments.length;\r\n\r\n                         if (argCount === 0) {\r\n                             // () - Global getter\r\n                             bool = !!animationsEnabled;\r\n                         } else {\r\n                             var hasElement = isElement(element);\r\n\r\n                             if (!hasElement) {\r\n                                 // (bool) - Global setter\r\n                                 bool = animationsEnabled = !!element;\r\n                             } else {\r\n                                 var node = getDomNode(element);\r\n\r\n                                 if (argCount === 1) {\r\n                                     // (element) - Element getter\r\n                                     bool = !disabledElementsLookup.get(node);\r\n                                 } else {\r\n                                     // (element, bool) - Element setter\r\n                                     disabledElementsLookup.set(node, !bool);\r\n                                 }\r\n                             }\r\n                         }\r\n\r\n                         return bool;\r\n                     }\r\n                 };\r\n\r\n                 return $animate;\r\n\r\n                 function queueAnimation(originalElement, event, initialOptions) {\r\n                     // we always make a copy of the options since\r\n                     // there should never be any side effects on\r\n                     // the input data when running `$animateCss`.\r\n                     var options = copy(initialOptions);\r\n\r\n                     var element = stripCommentsFromElement(originalElement);\r\n                     var node = getDomNode(element);\r\n                     var parentNode = node && node.parentNode;\r\n\r\n                     options = prepareAnimationOptions(options);\r\n\r\n                     // we create a fake runner with a working promise.\r\n                     // These methods will become available after the digest has passed\r\n                     var runner = new $$AnimateRunner();\r\n\r\n                     // this is used to trigger callbacks in postDigest mode\r\n                     var runInNextPostDigestOrNow = postDigestTaskFactory();\r\n\r\n                     if (isArray(options.addClass)) {\r\n                         options.addClass = options.addClass.join(' ');\r\n                     }\r\n\r\n                     if (options.addClass && !isString(options.addClass)) {\r\n                         options.addClass = null;\r\n                     }\r\n\r\n                     if (isArray(options.removeClass)) {\r\n                         options.removeClass = options.removeClass.join(' ');\r\n                     }\r\n\r\n                     if (options.removeClass && !isString(options.removeClass)) {\r\n                         options.removeClass = null;\r\n                     }\r\n\r\n                     if (options.from && !isObject(options.from)) {\r\n                         options.from = null;\r\n                     }\r\n\r\n                     if (options.to && !isObject(options.to)) {\r\n                         options.to = null;\r\n                     }\r\n\r\n                     // If animations are hard-disabled for the whole application there is no need to continue.\r\n                     // There are also situations where a directive issues an animation for a jqLite wrapper that\r\n                     // contains only comment nodes. In this case, there is no way we can perform an animation.\r\n                     if (!animationsEnabled ||\r\n                         !node ||\r\n                         !isAnimatableByFilter(node, event, initialOptions) ||\r\n                         !isAnimatableClassName(node, options)) {\r\n                         close();\r\n                         return runner;\r\n                     }\r\n\r\n                     var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\r\n\r\n                     var documentHidden = $$isDocumentHidden();\r\n\r\n                     // This is a hard disable of all animations the element itself, therefore  there is no need to\r\n                     // continue further past this point if not enabled\r\n                     // Animations are also disabled if the document is currently hidden (page is not visible\r\n                     // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\r\n                     var skipAnimations = documentHidden || disabledElementsLookup.get(node);\r\n                     var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\r\n                     var hasExistingAnimation = !!existingAnimation.state;\r\n\r\n                     // there is no point in traversing the same collection of parent ancestors if a followup\r\n                     // animation will be run on the same element that already did all that checking work\r\n                     if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {\r\n                         skipAnimations = !areAnimationsAllowed(node, parentNode, event);\r\n                     }\r\n\r\n                     if (skipAnimations) {\r\n                         // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\r\n                         if (documentHidden) notifyProgress(runner, event, 'start');\r\n                         close();\r\n                         if (documentHidden) notifyProgress(runner, event, 'close');\r\n                         return runner;\r\n                     }\r\n\r\n                     if (isStructural) {\r\n                         closeChildAnimations(node);\r\n                     }\r\n\r\n                     var newAnimation = {\r\n                         structural: isStructural,\r\n                         element: element,\r\n                         event: event,\r\n                         addClass: options.addClass,\r\n                         removeClass: options.removeClass,\r\n                         close: close,\r\n                         options: options,\r\n                         runner: runner\r\n                     };\r\n\r\n                     if (hasExistingAnimation) {\r\n                         var skipAnimationFlag = isAllowed('skip', newAnimation, existingAnimation);\r\n                         if (skipAnimationFlag) {\r\n                             if (existingAnimation.state === RUNNING_STATE) {\r\n                                 close();\r\n                                 return runner;\r\n                             } else {\r\n                                 mergeAnimationDetails(element, existingAnimation, newAnimation);\r\n                                 return existingAnimation.runner;\r\n                             }\r\n                         }\r\n                         var cancelAnimationFlag = isAllowed('cancel', newAnimation, existingAnimation);\r\n                         if (cancelAnimationFlag) {\r\n                             if (existingAnimation.state === RUNNING_STATE) {\r\n                                 // this will end the animation right away and it is safe\r\n                                 // to do so since the animation is already running and the\r\n                                 // runner callback code will run in async\r\n                                 existingAnimation.runner.end();\r\n                             } else if (existingAnimation.structural) {\r\n                                 // this means that the animation is queued into a digest, but\r\n                                 // hasn't started yet. Therefore it is safe to run the close\r\n                                 // method which will call the runner methods in async.\r\n                                 existingAnimation.close();\r\n                             } else {\r\n                                 // this will merge the new animation options into existing animation options\r\n                                 mergeAnimationDetails(element, existingAnimation, newAnimation);\r\n\r\n                                 return existingAnimation.runner;\r\n                             }\r\n                         } else {\r\n                             // a joined animation means that this animation will take over the existing one\r\n                             // so an example would involve a leave animation taking over an enter. Then when\r\n                             // the postDigest kicks in the enter will be ignored.\r\n                             var joinAnimationFlag = isAllowed('join', newAnimation, existingAnimation);\r\n                             if (joinAnimationFlag) {\r\n                                 if (existingAnimation.state === RUNNING_STATE) {\r\n                                     normalizeAnimationDetails(element, newAnimation);\r\n                                 } else {\r\n                                     applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\r\n\r\n                                     event = newAnimation.event = existingAnimation.event;\r\n                                     options = mergeAnimationDetails(element, existingAnimation, newAnimation);\r\n\r\n                                     //we return the same runner since only the option values of this animation will\r\n                                     //be fed into the `existingAnimation`.\r\n                                     return existingAnimation.runner;\r\n                                 }\r\n                             }\r\n                         }\r\n                     } else {\r\n                         // normalization in this case means that it removes redundant CSS classes that\r\n                         // already exist (addClass) or do not exist (removeClass) on the element\r\n                         normalizeAnimationDetails(element, newAnimation);\r\n                     }\r\n\r\n                     // when the options are merged and cleaned up we may end up not having to do\r\n                     // an animation at all, therefore we should check this before issuing a post\r\n                     // digest callback. Structural animations will always run no matter what.\r\n                     var isValidAnimation = newAnimation.structural;\r\n                     if (!isValidAnimation) {\r\n                         // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\r\n                         isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\r\n                                             || hasAnimationClasses(newAnimation);\r\n                     }\r\n\r\n                     if (!isValidAnimation) {\r\n                         close();\r\n                         clearElementAnimationState(node);\r\n                         return runner;\r\n                     }\r\n\r\n                     // the counter keeps track of cancelled animations\r\n                     var counter = (existingAnimation.counter || 0) + 1;\r\n                     newAnimation.counter = counter;\r\n\r\n                     markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);\r\n\r\n                     $rootScope.$$postDigest(function () {\r\n                         // It is possible that the DOM nodes inside `originalElement` have been replaced. This can\r\n                         // happen if the animated element is a transcluded clone and also has a `templateUrl`\r\n                         // directive on it. Therefore, we must recreate `element` in order to interact with the\r\n                         // actual DOM nodes.\r\n                         // Note: We still need to use the old `node` for certain things, such as looking up in\r\n                         //       HashMaps where it was used as the key.\r\n\r\n                         element = stripCommentsFromElement(originalElement);\r\n\r\n                         var animationDetails = activeAnimationsLookup.get(node);\r\n                         var animationCancelled = !animationDetails;\r\n                         animationDetails = animationDetails || {};\r\n\r\n                         // if addClass/removeClass is called before something like enter then the\r\n                         // registered parent element may not be present. The code below will ensure\r\n                         // that a final value for parent element is obtained\r\n                         var parentElement = element.parent() || [];\r\n\r\n                         // animate/structural/class-based animations all have requirements. Otherwise there\r\n                         // is no point in performing an animation. The parent node must also be set.\r\n                         var isValidAnimation = parentElement.length > 0\r\n                                                 && (animationDetails.event === 'animate'\r\n                                                     || animationDetails.structural\r\n                                                     || hasAnimationClasses(animationDetails));\r\n\r\n                         // this means that the previous animation was cancelled\r\n                         // even if the follow-up animation is the same event\r\n                         if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\r\n                             // if another animation did not take over then we need\r\n                             // to make sure that the domOperation and options are\r\n                             // handled accordingly\r\n                             if (animationCancelled) {\r\n                                 applyAnimationClasses(element, options);\r\n                                 applyAnimationStyles(element, options);\r\n                             }\r\n\r\n                             // if the event changed from something like enter to leave then we do\r\n                             // it, otherwise if it's the same then the end result will be the same too\r\n                             if (animationCancelled || (isStructural && animationDetails.event !== event)) {\r\n                                 options.domOperation();\r\n                                 runner.end();\r\n                             }\r\n\r\n                             // in the event that the element animation was not cancelled or a follow-up animation\r\n                             // isn't allowed to animate from here then we need to clear the state of the element\r\n                             // so that any future animations won't read the expired animation data.\r\n                             if (!isValidAnimation) {\r\n                                 clearElementAnimationState(node);\r\n                             }\r\n\r\n                             return;\r\n                         }\r\n\r\n                         // this combined multiple class to addClass / removeClass into a setClass event\r\n                         // so long as a structural event did not take over the animation\r\n                         event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\r\n                             ? 'setClass'\r\n                             : animationDetails.event;\r\n\r\n                         markElementAnimationState(node, RUNNING_STATE);\r\n                         var realRunner = $$animation(element, event, animationDetails.options);\r\n\r\n                         // this will update the runner's flow-control events based on\r\n                         // the `realRunner` object.\r\n                         runner.setHost(realRunner);\r\n                         notifyProgress(runner, event, 'start', {});\r\n\r\n                         realRunner.done(function (status) {\r\n                             close(!status);\r\n                             var animationDetails = activeAnimationsLookup.get(node);\r\n                             if (animationDetails && animationDetails.counter === counter) {\r\n                                 clearElementAnimationState(node);\r\n                             }\r\n                             notifyProgress(runner, event, 'close', {});\r\n                         });\r\n                     });\r\n\r\n                     return runner;\r\n\r\n                     function notifyProgress(runner, event, phase, data) {\r\n                         runInNextPostDigestOrNow(function () {\r\n                             var callbacks = findCallbacks(parentNode, node, event);\r\n                             if (callbacks.length) {\r\n                                 // do not optimize this call here to RAF because\r\n                                 // we don't know how heavy the callback code here will\r\n                                 // be and if this code is buffered then this can\r\n                                 // lead to a performance regression.\r\n                                 $$rAF(function () {\r\n                                     forEach(callbacks, function (callback) {\r\n                                         callback(element, phase, data);\r\n                                     });\r\n                                     cleanupEventListeners(phase, node);\r\n                                 });\r\n                             } else {\r\n                                 cleanupEventListeners(phase, node);\r\n                             }\r\n                         });\r\n                         runner.progress(event, phase, data);\r\n                     }\r\n\r\n                     function close(reject) {\r\n                         clearGeneratedClasses(element, options);\r\n                         applyAnimationClasses(element, options);\r\n                         applyAnimationStyles(element, options);\r\n                         options.domOperation();\r\n                         runner.complete(!reject);\r\n                     }\r\n                 }\r\n\r\n                 function closeChildAnimations(node) {\r\n                     var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\r\n                     forEach(children, function (child) {\r\n                         var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);\r\n                         var animationDetails = activeAnimationsLookup.get(child);\r\n                         if (animationDetails) {\r\n                             switch (state) {\r\n                                 case RUNNING_STATE:\r\n                                     animationDetails.runner.end();\r\n                                     /* falls through */\r\n                                 case PRE_DIGEST_STATE:\r\n                                     activeAnimationsLookup.delete(child);\r\n                                     break;\r\n                             }\r\n                         }\r\n                     });\r\n                 }\r\n\r\n                 function clearElementAnimationState(node) {\r\n                     node.removeAttribute(NG_ANIMATE_ATTR_NAME);\r\n                     activeAnimationsLookup.delete(node);\r\n                 }\r\n\r\n                 /**\r\n                  * This fn returns false if any of the following is true:\r\n                  * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\r\n                  * b) a parent element has an ongoing structural animation, and animateChildren is false\r\n                  * c) the element is not a child of the body\r\n                  * d) the element is not a child of the $rootElement\r\n                  */\r\n                 function areAnimationsAllowed(node, parentNode, event) {\r\n                     var bodyNode = $document[0].body;\r\n                     var rootNode = getDomNode($rootElement);\r\n\r\n                     var bodyNodeDetected = (node === bodyNode) || node.nodeName === 'HTML';\r\n                     var rootNodeDetected = (node === rootNode);\r\n                     var parentAnimationDetected = false;\r\n                     var elementDisabled = disabledElementsLookup.get(node);\r\n                     var animateChildren;\r\n\r\n                     var parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA);\r\n                     if (parentHost) {\r\n                         parentNode = getDomNode(parentHost);\r\n                     }\r\n\r\n                     while (parentNode) {\r\n                         if (!rootNodeDetected) {\r\n                             // AngularJS doesn't want to attempt to animate elements outside of the application\r\n                             // therefore we need to ensure that the rootElement is an ancestor of the current element\r\n                             rootNodeDetected = (parentNode === rootNode);\r\n                         }\r\n\r\n                         if (parentNode.nodeType !== ELEMENT_NODE) {\r\n                             // no point in inspecting the #document element\r\n                             break;\r\n                         }\r\n\r\n                         var details = activeAnimationsLookup.get(parentNode) || {};\r\n                         // either an enter, leave or move animation will commence\r\n                         // therefore we can't allow any animations to take place\r\n                         // but if a parent animation is class-based then that's ok\r\n                         if (!parentAnimationDetected) {\r\n                             var parentNodeDisabled = disabledElementsLookup.get(parentNode);\r\n\r\n                             if (parentNodeDisabled === true && elementDisabled !== false) {\r\n                                 // disable animations if the user hasn't explicitly enabled animations on the\r\n                                 // current element\r\n                                 elementDisabled = true;\r\n                                 // element is disabled via parent element, no need to check anything else\r\n                                 break;\r\n                             } else if (parentNodeDisabled === false) {\r\n                                 elementDisabled = false;\r\n                             }\r\n                             parentAnimationDetected = details.structural;\r\n                         }\r\n\r\n                         if (isUndefined(animateChildren) || animateChildren === true) {\r\n                             var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA);\r\n                             if (isDefined(value)) {\r\n                                 animateChildren = value;\r\n                             }\r\n                         }\r\n\r\n                         // there is no need to continue traversing at this point\r\n                         if (parentAnimationDetected && animateChildren === false) break;\r\n\r\n                         if (!bodyNodeDetected) {\r\n                             // we also need to ensure that the element is or will be a part of the body element\r\n                             // otherwise it is pointless to even issue an animation to be rendered\r\n                             bodyNodeDetected = (parentNode === bodyNode);\r\n                         }\r\n\r\n                         if (bodyNodeDetected && rootNodeDetected) {\r\n                             // If both body and root have been found, any other checks are pointless,\r\n                             // as no animation data should live outside the application\r\n                             break;\r\n                         }\r\n\r\n                         if (!rootNodeDetected) {\r\n                             // If `rootNode` is not detected, check if `parentNode` is pinned to another element\r\n                             parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA);\r\n                             if (parentHost) {\r\n                                 // The pin target element becomes the next parent element\r\n                                 parentNode = getDomNode(parentHost);\r\n                                 continue;\r\n                             }\r\n                         }\r\n\r\n                         parentNode = parentNode.parentNode;\r\n                     }\r\n\r\n                     var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\r\n                     return allowAnimation && rootNodeDetected && bodyNodeDetected;\r\n                 }\r\n\r\n                 function markElementAnimationState(node, state, details) {\r\n                     details = details || {};\r\n                     details.state = state;\r\n\r\n                     node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\r\n\r\n                     var oldValue = activeAnimationsLookup.get(node);\r\n                     var newValue = oldValue\r\n                         ? extend(oldValue, details)\r\n                         : details;\r\n                     activeAnimationsLookup.set(node, newValue);\r\n                 }\r\n             }];\r\n    }];\r\n\r\n    /* exported $$AnimationProvider */\r\n\r\n    var $$AnimationProvider = ['$animateProvider', /** @this */ function ($animateProvider) {\r\n        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\r\n\r\n        var drivers = this.drivers = [];\r\n\r\n        var RUNNER_STORAGE_KEY = '$$animationRunner';\r\n\r\n        function setRunner(element, runner) {\r\n            element.data(RUNNER_STORAGE_KEY, runner);\r\n        }\r\n\r\n        function removeRunner(element) {\r\n            element.removeData(RUNNER_STORAGE_KEY);\r\n        }\r\n\r\n        function getRunner(element) {\r\n            return element.data(RUNNER_STORAGE_KEY);\r\n        }\r\n\r\n        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$Map', '$$rAFScheduler',\r\n             function ($$jqLite, $rootScope, $injector, $$AnimateRunner, $$Map, $$rAFScheduler) {\r\n\r\n                 var animationQueue = [];\r\n                 var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\r\n\r\n                 function sortAnimations(animations) {\r\n                     var tree = { children: [] };\r\n                     var i, lookup = new $$Map();\r\n\r\n                     // this is done first beforehand so that the map\r\n                     // is filled with a list of the elements that will be animated\r\n                     for (i = 0; i < animations.length; i++) {\r\n                         var animation = animations[i];\r\n                         lookup.set(animation.domNode, animations[i] = {\r\n                             domNode: animation.domNode,\r\n                             fn: animation.fn,\r\n                             children: []\r\n                         });\r\n                     }\r\n\r\n                     for (i = 0; i < animations.length; i++) {\r\n                         processNode(animations[i]);\r\n                     }\r\n\r\n                     return flatten(tree);\r\n\r\n                     function processNode(entry) {\r\n                         if (entry.processed) return entry;\r\n                         entry.processed = true;\r\n\r\n                         var elementNode = entry.domNode;\r\n                         var parentNode = elementNode.parentNode;\r\n                         lookup.set(elementNode, entry);\r\n\r\n                         var parentEntry;\r\n                         while (parentNode) {\r\n                             parentEntry = lookup.get(parentNode);\r\n                             if (parentEntry) {\r\n                                 if (!parentEntry.processed) {\r\n                                     parentEntry = processNode(parentEntry);\r\n                                 }\r\n                                 break;\r\n                             }\r\n                             parentNode = parentNode.parentNode;\r\n                         }\r\n\r\n                         (parentEntry || tree).children.push(entry);\r\n                         return entry;\r\n                     }\r\n\r\n                     function flatten(tree) {\r\n                         var result = [];\r\n                         var queue = [];\r\n                         var i;\r\n\r\n                         for (i = 0; i < tree.children.length; i++) {\r\n                             queue.push(tree.children[i]);\r\n                         }\r\n\r\n                         var remainingLevelEntries = queue.length;\r\n                         var nextLevelEntries = 0;\r\n                         var row = [];\r\n\r\n                         for (i = 0; i < queue.length; i++) {\r\n                             var entry = queue[i];\r\n                             if (remainingLevelEntries <= 0) {\r\n                                 remainingLevelEntries = nextLevelEntries;\r\n                                 nextLevelEntries = 0;\r\n                                 result.push(row);\r\n                                 row = [];\r\n                             }\r\n                             row.push(entry.fn);\r\n                             entry.children.forEach(function (childEntry) {\r\n                                 nextLevelEntries++;\r\n                                 queue.push(childEntry);\r\n                             });\r\n                             remainingLevelEntries--;\r\n                         }\r\n\r\n                         if (row.length) {\r\n                             result.push(row);\r\n                         }\r\n\r\n                         return result;\r\n                     }\r\n                 }\r\n\r\n                 // TODO(matsko): document the signature in a better way\r\n                 return function (element, event, options) {\r\n                     options = prepareAnimationOptions(options);\r\n                     var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\r\n\r\n                     // there is no animation at the current moment, however\r\n                     // these runner methods will get later updated with the\r\n                     // methods leading into the driver's end/cancel methods\r\n                     // for now they just stop the animation from starting\r\n                     var runner = new $$AnimateRunner({\r\n                         end: function () { close(); },\r\n                         cancel: function () { close(true); }\r\n                     });\r\n\r\n                     if (!drivers.length) {\r\n                         close();\r\n                         return runner;\r\n                     }\r\n\r\n                     setRunner(element, runner);\r\n\r\n                     var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\r\n                     var tempClasses = options.tempClasses;\r\n                     if (tempClasses) {\r\n                         classes += ' ' + tempClasses;\r\n                         options.tempClasses = null;\r\n                     }\r\n\r\n                     var prepareClassName;\r\n                     if (isStructural) {\r\n                         prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\r\n                         $$jqLite.addClass(element, prepareClassName);\r\n                     }\r\n\r\n                     animationQueue.push({\r\n                         // this data is used by the postDigest code and passed into\r\n                         // the driver step function\r\n                         element: element,\r\n                         classes: classes,\r\n                         event: event,\r\n                         structural: isStructural,\r\n                         options: options,\r\n                         beforeStart: beforeStart,\r\n                         close: close\r\n                     });\r\n\r\n                     element.on('$destroy', handleDestroyedElement);\r\n\r\n                     // we only want there to be one function called within the post digest\r\n                     // block. This way we can group animations for all the animations that\r\n                     // were apart of the same postDigest flush call.\r\n                     if (animationQueue.length > 1) return runner;\r\n\r\n                     $rootScope.$$postDigest(function () {\r\n                         var animations = [];\r\n                         forEach(animationQueue, function (entry) {\r\n                             // the element was destroyed early on which removed the runner\r\n                             // form its storage. This means we can't animate this element\r\n                             // at all and it already has been closed due to destruction.\r\n                             if (getRunner(entry.element)) {\r\n                                 animations.push(entry);\r\n                             } else {\r\n                                 entry.close();\r\n                             }\r\n                         });\r\n\r\n                         // now any future animations will be in another postDigest\r\n                         animationQueue.length = 0;\r\n\r\n                         var groupedAnimations = groupAnimations(animations);\r\n                         var toBeSortedAnimations = [];\r\n\r\n                         forEach(groupedAnimations, function (animationEntry) {\r\n                             toBeSortedAnimations.push({\r\n                                 domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\r\n                                 fn: function triggerAnimationStart() {\r\n                                     // it's important that we apply the `ng-animate` CSS class and the\r\n                                     // temporary classes before we do any driver invoking since these\r\n                                     // CSS classes may be required for proper CSS detection.\r\n                                     animationEntry.beforeStart();\r\n\r\n                                     var startAnimationFn, closeFn = animationEntry.close;\r\n\r\n                                     // in the event that the element was removed before the digest runs or\r\n                                     // during the RAF sequencing then we should not trigger the animation.\r\n                                     var targetElement = animationEntry.anchors\r\n                                         ? (animationEntry.from.element || animationEntry.to.element)\r\n                                         : animationEntry.element;\r\n\r\n                                     if (getRunner(targetElement)) {\r\n                                         var operation = invokeFirstDriver(animationEntry);\r\n                                         if (operation) {\r\n                                             startAnimationFn = operation.start;\r\n                                         }\r\n                                     }\r\n\r\n                                     if (!startAnimationFn) {\r\n                                         closeFn();\r\n                                     } else {\r\n                                         var animationRunner = startAnimationFn();\r\n                                         animationRunner.done(function (status) {\r\n                                             closeFn(!status);\r\n                                         });\r\n                                         updateAnimationRunners(animationEntry, animationRunner);\r\n                                     }\r\n                                 }\r\n                             });\r\n                         });\r\n\r\n                         // we need to sort each of the animations in order of parent to child\r\n                         // relationships. This ensures that the child classes are applied at the\r\n                         // right time.\r\n                         $$rAFScheduler(sortAnimations(toBeSortedAnimations));\r\n                     });\r\n\r\n                     return runner;\r\n\r\n                     // TODO(matsko): change to reference nodes\r\n                     function getAnchorNodes(node) {\r\n                         var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\r\n                         var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\r\n                               ? [node]\r\n                               : node.querySelectorAll(SELECTOR);\r\n                         var anchors = [];\r\n                         forEach(items, function (node) {\r\n                             var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\r\n                             if (attr && attr.length) {\r\n                                 anchors.push(node);\r\n                             }\r\n                         });\r\n                         return anchors;\r\n                     }\r\n\r\n                     function groupAnimations(animations) {\r\n                         var preparedAnimations = [];\r\n                         var refLookup = {};\r\n                         forEach(animations, function (animation, index) {\r\n                             var element = animation.element;\r\n                             var node = getDomNode(element);\r\n                             var event = animation.event;\r\n                             var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\r\n                             var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\r\n\r\n                             if (anchorNodes.length) {\r\n                                 var direction = enterOrMove ? 'to' : 'from';\r\n\r\n                                 forEach(anchorNodes, function (anchor) {\r\n                                     var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\r\n                                     refLookup[key] = refLookup[key] || {};\r\n                                     refLookup[key][direction] = {\r\n                                         animationID: index,\r\n                                         element: jqLite(anchor)\r\n                                     };\r\n                                 });\r\n                             } else {\r\n                                 preparedAnimations.push(animation);\r\n                             }\r\n                         });\r\n\r\n                         var usedIndicesLookup = {};\r\n                         var anchorGroups = {};\r\n                         forEach(refLookup, function (operations, key) {\r\n                             var from = operations.from;\r\n                             var to = operations.to;\r\n\r\n                             if (!from || !to) {\r\n                                 // only one of these is set therefore we can't have an\r\n                                 // anchor animation since all three pieces are required\r\n                                 var index = from ? from.animationID : to.animationID;\r\n                                 var indexKey = index.toString();\r\n                                 if (!usedIndicesLookup[indexKey]) {\r\n                                     usedIndicesLookup[indexKey] = true;\r\n                                     preparedAnimations.push(animations[index]);\r\n                                 }\r\n                                 return;\r\n                             }\r\n\r\n                             var fromAnimation = animations[from.animationID];\r\n                             var toAnimation = animations[to.animationID];\r\n                             var lookupKey = from.animationID.toString();\r\n                             if (!anchorGroups[lookupKey]) {\r\n                                 var group = anchorGroups[lookupKey] = {\r\n                                     structural: true,\r\n                                     beforeStart: function () {\r\n                                         fromAnimation.beforeStart();\r\n                                         toAnimation.beforeStart();\r\n                                     },\r\n                                     close: function () {\r\n                                         fromAnimation.close();\r\n                                         toAnimation.close();\r\n                                     },\r\n                                     classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\r\n                                     from: fromAnimation,\r\n                                     to: toAnimation,\r\n                                     anchors: [] // TODO(matsko): change to reference nodes\r\n                                 };\r\n\r\n                                 // the anchor animations require that the from and to elements both have at least\r\n                                 // one shared CSS class which effectively marries the two elements together to use\r\n                                 // the same animation driver and to properly sequence the anchor animation.\r\n                                 if (group.classes.length) {\r\n                                     preparedAnimations.push(group);\r\n                                 } else {\r\n                                     preparedAnimations.push(fromAnimation);\r\n                                     preparedAnimations.push(toAnimation);\r\n                                 }\r\n                             }\r\n\r\n                             anchorGroups[lookupKey].anchors.push({\r\n                                 'out': from.element, 'in': to.element\r\n                             });\r\n                         });\r\n\r\n                         return preparedAnimations;\r\n                     }\r\n\r\n                     function cssClassesIntersection(a, b) {\r\n                         a = a.split(' ');\r\n                         b = b.split(' ');\r\n                         var matches = [];\r\n\r\n                         for (var i = 0; i < a.length; i++) {\r\n                             var aa = a[i];\r\n                             if (aa.substring(0, 3) === 'ng-') continue;\r\n\r\n                             for (var j = 0; j < b.length; j++) {\r\n                                 if (aa === b[j]) {\r\n                                     matches.push(aa);\r\n                                     break;\r\n                                 }\r\n                             }\r\n                         }\r\n\r\n                         return matches.join(' ');\r\n                     }\r\n\r\n                     function invokeFirstDriver(animationDetails) {\r\n                         // we loop in reverse order since the more general drivers (like CSS and JS)\r\n                         // may attempt more elements, but custom drivers are more particular\r\n                         for (var i = drivers.length - 1; i >= 0; i--) {\r\n                             var driverName = drivers[i];\r\n                             var factory = $injector.get(driverName);\r\n                             var driver = factory(animationDetails);\r\n                             if (driver) {\r\n                                 return driver;\r\n                             }\r\n                         }\r\n                     }\r\n\r\n                     function beforeStart() {\r\n                         element.addClass(NG_ANIMATE_CLASSNAME);\r\n                         if (tempClasses) {\r\n                             $$jqLite.addClass(element, tempClasses);\r\n                         }\r\n                         if (prepareClassName) {\r\n                             $$jqLite.removeClass(element, prepareClassName);\r\n                             prepareClassName = null;\r\n                         }\r\n                     }\r\n\r\n                     function updateAnimationRunners(animation, newRunner) {\r\n                         if (animation.from && animation.to) {\r\n                             update(animation.from.element);\r\n                             update(animation.to.element);\r\n                         } else {\r\n                             update(animation.element);\r\n                         }\r\n\r\n                         function update(element) {\r\n                             var runner = getRunner(element);\r\n                             if (runner) runner.setHost(newRunner);\r\n                         }\r\n                     }\r\n\r\n                     function handleDestroyedElement() {\r\n                         var runner = getRunner(element);\r\n                         if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\r\n                             runner.end();\r\n                         }\r\n                     }\r\n\r\n                     function close(rejected) {\r\n                         element.off('$destroy', handleDestroyedElement);\r\n                         removeRunner(element);\r\n\r\n                         applyAnimationClasses(element, options);\r\n                         applyAnimationStyles(element, options);\r\n                         options.domOperation();\r\n\r\n                         if (tempClasses) {\r\n                             $$jqLite.removeClass(element, tempClasses);\r\n                         }\r\n\r\n                         element.removeClass(NG_ANIMATE_CLASSNAME);\r\n                         runner.complete(!rejected);\r\n                     }\r\n                 };\r\n             }];\r\n    }];\r\n\r\n    /**\r\n     * @ngdoc directive\r\n     * @name ngAnimateSwap\r\n     * @restrict A\r\n     * @scope\r\n     *\r\n     * @description\r\n     *\r\n     * ngAnimateSwap is a animation-oriented directive that allows for the container to\r\n     * be removed and entered in whenever the associated expression changes. A\r\n     * common usecase for this directive is a rotating banner or slider component which\r\n     * contains one image being present at a time. When the active image changes\r\n     * then the old image will perform a `leave` animation and the new element\r\n     * will be inserted via an `enter` animation.\r\n     *\r\n     * @animations\r\n     * | Animation                        | Occurs                               |\r\n     * |----------------------------------|--------------------------------------|\r\n     * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\r\n     * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\r\n     *\r\n     * @example\r\n     * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\r\n     *          deps=\"angular-animate.js\"\r\n     *          animations=\"true\" fixBase=\"true\">\r\n     *   <file name=\"index.html\">\r\n     *     <div class=\"container\" ng-controller=\"AppCtrl\">\r\n     *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\r\n     *         {{ number }}\r\n     *       </div>\r\n     *     </div>\r\n     *   </file>\r\n     *   <file name=\"script.js\">\r\n     *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\r\n     *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\r\n     *         $scope.number = 0;\r\n     *         $interval(function() {\r\n     *           $scope.number++;\r\n     *         }, 1000);\r\n     *\r\n     *         var colors = ['red','blue','green','yellow','orange'];\r\n     *         $scope.colorClass = function(number) {\r\n     *           return colors[number % colors.length];\r\n     *         };\r\n     *       }]);\r\n     *   </file>\r\n     *  <file name=\"animations.css\">\r\n     *  .container {\r\n     *    height:250px;\r\n     *    width:250px;\r\n     *    position:relative;\r\n     *    overflow:hidden;\r\n     *    border:2px solid black;\r\n     *  }\r\n     *  .container .cell {\r\n     *    font-size:150px;\r\n     *    text-align:center;\r\n     *    line-height:250px;\r\n     *    position:absolute;\r\n     *    top:0;\r\n     *    left:0;\r\n     *    right:0;\r\n     *    border-bottom:2px solid black;\r\n     *  }\r\n     *  .swap-animation.ng-enter, .swap-animation.ng-leave {\r\n     *    transition:0.5s linear all;\r\n     *  }\r\n     *  .swap-animation.ng-enter {\r\n     *    top:-250px;\r\n     *  }\r\n     *  .swap-animation.ng-enter-active {\r\n     *    top:0px;\r\n     *  }\r\n     *  .swap-animation.ng-leave {\r\n     *    top:0px;\r\n     *  }\r\n     *  .swap-animation.ng-leave-active {\r\n     *    top:250px;\r\n     *  }\r\n     *  .red { background:red; }\r\n     *  .green { background:green; }\r\n     *  .blue { background:blue; }\r\n     *  .yellow { background:yellow; }\r\n     *  .orange { background:orange; }\r\n     *  </file>\r\n     * </example>\r\n     */\r\n    var ngAnimateSwapDirective = ['$animate', function ($animate) {\r\n        return {\r\n            restrict: 'A',\r\n            transclude: 'element',\r\n            terminal: true,\r\n            priority: 600, // we use 600 here to ensure that the directive is caught before others\r\n            link: function (scope, $element, attrs, ctrl, $transclude) {\r\n                var previousElement, previousScope;\r\n                scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function (value) {\r\n                    if (previousElement) {\r\n                        $animate.leave(previousElement);\r\n                    }\r\n                    if (previousScope) {\r\n                        previousScope.$destroy();\r\n                        previousScope = null;\r\n                    }\r\n                    if (value || value === 0) {\r\n                        $transclude(function (clone, childScope) {\r\n                            previousElement = clone;\r\n                            previousScope = childScope;\r\n                            $animate.enter(clone, null, $element);\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        };\r\n    }];\r\n\r\n    /**\r\n     * @ngdoc module\r\n     * @name ngAnimate\r\n     * @description\r\n     *\r\n     * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\r\n     * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an AngularJS app.\r\n     *\r\n     * ## Usage\r\n     * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\r\n     * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\r\n     * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\r\n     * the HTML element that the animation will be triggered on.\r\n     *\r\n     * ## Directive Support\r\n     * The following directives are \"animation aware\":\r\n     *\r\n     * | Directive                                                                     | Supported Animations                                                      |\r\n     * |-------------------------------------------------------------------------------|---------------------------------------------------------------------------|\r\n     * | {@link ng.directive:form#animations form / ngForm}                            | add and remove ({@link ng.directive:form#css-classes various classes})    |\r\n     * | {@link ngAnimate.directive:ngAnimateSwap#animations ngAnimateSwap}            | enter and leave                                                           |\r\n     * | {@link ng.directive:ngClass#animations ngClass / {{class&#125;&#8203;&#125;}  | add and remove                                                            |\r\n     * | {@link ng.directive:ngClassEven#animations ngClassEven}                       | add and remove                                                            |\r\n     * | {@link ng.directive:ngClassOdd#animations ngClassOdd}                         | add and remove                                                            |\r\n     * | {@link ng.directive:ngHide#animations ngHide}                                 | add and remove (the `ng-hide` class)                                      |\r\n     * | {@link ng.directive:ngIf#animations ngIf}                                     | enter and leave                                                           |\r\n     * | {@link ng.directive:ngInclude#animations ngInclude}                           | enter and leave                                                           |\r\n     * | {@link module:ngMessages#animations ngMessage / ngMessageExp}                 | enter and leave                                                           |\r\n     * | {@link module:ngMessages#animations ngMessages}                               | add and remove (the `ng-active`/`ng-inactive` classes)                    |\r\n     * | {@link ng.directive:ngModel#animations ngModel}                               | add and remove ({@link ng.directive:ngModel#css-classes various classes}) |\r\n     * | {@link ng.directive:ngRepeat#animations ngRepeat}                             | enter, leave, and move                                                    |\r\n     * | {@link ng.directive:ngShow#animations ngShow}                                 | add and remove (the `ng-hide` class)                                      |\r\n     * | {@link ng.directive:ngSwitch#animations ngSwitch}                             | enter and leave                                                           |\r\n     * | {@link ngRoute.directive:ngView#animations ngView}                            | enter and leave                                                           |\r\n     *\r\n     * (More information can be found by visiting the documentation associated with each directive.)\r\n     *\r\n     * For a full breakdown of the steps involved during each animation event, refer to the\r\n     * {@link ng.$animate `$animate` API docs}.\r\n     *\r\n     * ## CSS-based Animations\r\n     *\r\n     * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\r\n     * and CSS code we can create an animation that will be picked up by AngularJS when an underlying directive performs an operation.\r\n     *\r\n     * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\r\n     *\r\n     * ```html\r\n     * <div ng-if=\"bool\" class=\"fade\">\r\n     *    Fade me in out\r\n     * </div>\r\n     * <button ng-click=\"bool=true\">Fade In!</button>\r\n     * <button ng-click=\"bool=false\">Fade Out!</button>\r\n     * ```\r\n     *\r\n     * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\r\n     *\r\n     * ```css\r\n     * /&#42; The starting CSS styles for the enter animation &#42;/\r\n     * .fade.ng-enter {\r\n     *   transition:0.5s linear all;\r\n     *   opacity:0;\r\n     * }\r\n     *\r\n     * /&#42; The finishing CSS styles for the enter animation &#42;/\r\n     * .fade.ng-enter.ng-enter-active {\r\n     *   opacity:1;\r\n     * }\r\n     * ```\r\n     *\r\n     * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\r\n     * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\r\n     * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\r\n     *\r\n     * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\r\n     *\r\n     * ```css\r\n     * /&#42; now the element will fade out before it is removed from the DOM &#42;/\r\n     * .fade.ng-leave {\r\n     *   transition:0.5s linear all;\r\n     *   opacity:1;\r\n     * }\r\n     * .fade.ng-leave.ng-leave-active {\r\n     *   opacity:0;\r\n     * }\r\n     * ```\r\n     *\r\n     * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\r\n     *\r\n     * ```css\r\n     * /&#42; there is no need to define anything inside of the destination\r\n     * CSS class since the keyframe will take charge of the animation &#42;/\r\n     * .fade.ng-leave {\r\n     *   animation: my_fade_animation 0.5s linear;\r\n     *   -webkit-animation: my_fade_animation 0.5s linear;\r\n     * }\r\n     *\r\n     * @keyframes my_fade_animation {\r\n     *   from { opacity:1; }\r\n     *   to { opacity:0; }\r\n     * }\r\n     *\r\n     * @-webkit-keyframes my_fade_animation {\r\n     *   from { opacity:1; }\r\n     *   to { opacity:0; }\r\n     * }\r\n     * ```\r\n     *\r\n     * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\r\n     *\r\n     * ### CSS Class-based Animations\r\n     *\r\n     * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\r\n     * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\r\n     * and removed.\r\n     *\r\n     * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\r\n     *\r\n     * ```html\r\n     * <div ng-show=\"bool\" class=\"fade\">\r\n     *   Show and hide me\r\n     * </div>\r\n     * <button ng-click=\"bool=!bool\">Toggle</button>\r\n     *\r\n     * <style>\r\n     * .fade.ng-hide {\r\n     *   transition:0.5s linear all;\r\n     *   opacity:0;\r\n     * }\r\n     * </style>\r\n     * ```\r\n     *\r\n     * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\r\n     * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\r\n     *\r\n     * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\r\n     * with CSS styles.\r\n     *\r\n     * ```html\r\n     * <div ng-class=\"{on:onOff}\" class=\"highlight\">\r\n     *   Highlight this box\r\n     * </div>\r\n     * <button ng-click=\"onOff=!onOff\">Toggle</button>\r\n     *\r\n     * <style>\r\n     * .highlight {\r\n     *   transition:0.5s linear all;\r\n     * }\r\n     * .highlight.on-add {\r\n     *   background:white;\r\n     * }\r\n     * .highlight.on {\r\n     *   background:yellow;\r\n     * }\r\n     * .highlight.on-remove {\r\n     *   background:black;\r\n     * }\r\n     * </style>\r\n     * ```\r\n     *\r\n     * We can also make use of CSS keyframes by placing them within the CSS classes.\r\n     *\r\n     *\r\n     * ### CSS Staggering Animations\r\n     * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\r\n     * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\r\n     * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\r\n     * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\r\n     * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\r\n     *\r\n     * ```css\r\n     * .my-animation.ng-enter {\r\n     *   /&#42; standard transition code &#42;/\r\n     *   transition: 1s linear all;\r\n     *   opacity:0;\r\n     * }\r\n     * .my-animation.ng-enter-stagger {\r\n     *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\r\n     *   transition-delay: 0.1s;\r\n     *\r\n     *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\r\n     *     to not accidentally inherit a delay property from another CSS class &#42;/\r\n     *   transition-duration: 0s;\r\n     *\r\n     *   /&#42; if you are using animations instead of transitions you should configure as follows:\r\n     *     animation-delay: 0.1s;\r\n     *     animation-duration: 0s; &#42;/\r\n     * }\r\n     * .my-animation.ng-enter.ng-enter-active {\r\n     *   /&#42; standard transition styles &#42;/\r\n     *   opacity:1;\r\n     * }\r\n     * ```\r\n     *\r\n     * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\r\n     * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\r\n     * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\r\n     * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\r\n     *\r\n     * The following code will issue the **ng-leave-stagger** event on the element provided:\r\n     *\r\n     * ```js\r\n     * var kids = parent.children();\r\n     *\r\n     * $animate.leave(kids[0]); //stagger index=0\r\n     * $animate.leave(kids[1]); //stagger index=1\r\n     * $animate.leave(kids[2]); //stagger index=2\r\n     * $animate.leave(kids[3]); //stagger index=3\r\n     * $animate.leave(kids[4]); //stagger index=4\r\n     *\r\n     * window.requestAnimationFrame(function() {\r\n     *   //stagger has reset itself\r\n     *   $animate.leave(kids[5]); //stagger index=0\r\n     *   $animate.leave(kids[6]); //stagger index=1\r\n     *\r\n     *   $scope.$digest();\r\n     * });\r\n     * ```\r\n     *\r\n     * Stagger animations are currently only supported within CSS-defined animations.\r\n     *\r\n     * ### The `ng-animate` CSS class\r\n     *\r\n     * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\r\n     * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\r\n     *\r\n     * Therefore, animations can be applied to an element using this temporary class directly via CSS.\r\n     *\r\n     * ```css\r\n     * .zipper.ng-animate {\r\n     *   transition:0.5s linear all;\r\n     * }\r\n     * .zipper.ng-enter {\r\n     *   opacity:0;\r\n     * }\r\n     * .zipper.ng-enter.ng-enter-active {\r\n     *   opacity:1;\r\n     * }\r\n     * .zipper.ng-leave {\r\n     *   opacity:1;\r\n     * }\r\n     * .zipper.ng-leave.ng-leave-active {\r\n     *   opacity:0;\r\n     * }\r\n     * ```\r\n     *\r\n     * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\r\n     * the CSS class once an animation has completed.)\r\n     *\r\n     *\r\n     * ### The `ng-[event]-prepare` class\r\n     *\r\n     * This is a special class that can be used to prevent unwanted flickering / flash of content before\r\n     * the actual animation starts. The class is added as soon as an animation is initialized, but removed\r\n     * before the actual animation starts (after waiting for a $digest).\r\n     * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\r\n     *\r\n     * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\r\n     * into elements that have class-based animations such as `ngClass`.\r\n     *\r\n     * ```html\r\n     * <div ng-class=\"{red: myProp}\">\r\n     *   <div ng-class=\"{blue: myProp}\">\r\n     *     <div class=\"message\" ng-if=\"myProp\"></div>\r\n     *   </div>\r\n     * </div>\r\n     * ```\r\n     *\r\n     * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\r\n     * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\r\n     *\r\n     * ```css\r\n     * .message.ng-enter-prepare {\r\n     *   opacity: 0;\r\n     * }\r\n     * ```\r\n     *\r\n     * ### Animating between value changes\r\n     *\r\n     * Sometimes you need to animate between different expression states, whose values\r\n     * don't necessary need to be known or referenced in CSS styles.\r\n     * Unless possible with another {@link ngAnimate#directive-support \"animation aware\" directive},\r\n     * that specific use case can always be covered with {@link ngAnimate.directive:ngAnimateSwap} as\r\n     * can be seen in {@link ngAnimate.directive:ngAnimateSwap#examples this example}.\r\n     *\r\n     * Note that {@link ngAnimate.directive:ngAnimateSwap} is a *structural directive*, which means it\r\n     * creates a new instance of the element (including any other/child directives it may have) and\r\n     * links it to a new scope every time *swap* happens. In some cases this might not be desirable\r\n     * (e.g. for performance reasons, or when you wish to retain internal state on the original\r\n     * element instance).\r\n     *\r\n     * ## JavaScript-based Animations\r\n     *\r\n     * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\r\n     * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\r\n     * `module.animation()` module function we can register the animation.\r\n     *\r\n     * Let's see an example of a enter/leave animation using `ngRepeat`:\r\n     *\r\n     * ```html\r\n     * <div ng-repeat=\"item in items\" class=\"slide\">\r\n     *   {{ item }}\r\n     * </div>\r\n     * ```\r\n     *\r\n     * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\r\n     *\r\n     * ```js\r\n     * myModule.animation('.slide', [function() {\r\n     *   return {\r\n     *     // make note that other events (like addClass/removeClass)\r\n     *     // have different function input parameters\r\n     *     enter: function(element, doneFn) {\r\n     *       jQuery(element).fadeIn(1000, doneFn);\r\n     *\r\n     *       // remember to call doneFn so that AngularJS\r\n     *       // knows that the animation has concluded\r\n     *     },\r\n     *\r\n     *     move: function(element, doneFn) {\r\n     *       jQuery(element).fadeIn(1000, doneFn);\r\n     *     },\r\n     *\r\n     *     leave: function(element, doneFn) {\r\n     *       jQuery(element).fadeOut(1000, doneFn);\r\n     *     }\r\n     *   }\r\n     * }]);\r\n     * ```\r\n     *\r\n     * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\r\n     * greensock.js and velocity.js.\r\n     *\r\n     * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\r\n     * our animations inside of the same registered animation, however, the function input arguments are a bit different:\r\n     *\r\n     * ```html\r\n     * <div ng-class=\"color\" class=\"colorful\">\r\n     *   this box is moody\r\n     * </div>\r\n     * <button ng-click=\"color='red'\">Change to red</button>\r\n     * <button ng-click=\"color='blue'\">Change to blue</button>\r\n     * <button ng-click=\"color='green'\">Change to green</button>\r\n     * ```\r\n     *\r\n     * ```js\r\n     * myModule.animation('.colorful', [function() {\r\n     *   return {\r\n     *     addClass: function(element, className, doneFn) {\r\n     *       // do some cool animation and call the doneFn\r\n     *     },\r\n     *     removeClass: function(element, className, doneFn) {\r\n     *       // do some cool animation and call the doneFn\r\n     *     },\r\n     *     setClass: function(element, addedClass, removedClass, doneFn) {\r\n     *       // do some cool animation and call the doneFn\r\n     *     }\r\n     *   }\r\n     * }]);\r\n     * ```\r\n     *\r\n     * ## CSS + JS Animations Together\r\n     *\r\n     * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of AngularJS,\r\n     * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\r\n     * charge of the animation**:\r\n     *\r\n     * ```html\r\n     * <div ng-if=\"bool\" class=\"slide\">\r\n     *   Slide in and out\r\n     * </div>\r\n     * ```\r\n     *\r\n     * ```js\r\n     * myModule.animation('.slide', [function() {\r\n     *   return {\r\n     *     enter: function(element, doneFn) {\r\n     *       jQuery(element).slideIn(1000, doneFn);\r\n     *     }\r\n     *   }\r\n     * }]);\r\n     * ```\r\n     *\r\n     * ```css\r\n     * .slide.ng-enter {\r\n     *   transition:0.5s linear all;\r\n     *   transform:translateY(-100px);\r\n     * }\r\n     * .slide.ng-enter.ng-enter-active {\r\n     *   transform:translateY(0);\r\n     * }\r\n     * ```\r\n     *\r\n     * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\r\n     * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\r\n     * our own JS-based animation code:\r\n     *\r\n     * ```js\r\n     * myModule.animation('.slide', ['$animateCss', function($animateCss) {\r\n     *   return {\r\n     *     enter: function(element) {\r\n    *        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\r\n     *       return $animateCss(element, {\r\n     *         event: 'enter',\r\n     *         structural: true\r\n     *       });\r\n     *     }\r\n     *   }\r\n     * }]);\r\n     * ```\r\n     *\r\n     * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\r\n     *\r\n     * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\r\n     * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\r\n     * data into `$animateCss` directly:\r\n     *\r\n     * ```js\r\n     * myModule.animation('.slide', ['$animateCss', function($animateCss) {\r\n     *   return {\r\n     *     enter: function(element) {\r\n     *       return $animateCss(element, {\r\n     *         event: 'enter',\r\n     *         structural: true,\r\n     *         addClass: 'maroon-setting',\r\n     *         from: { height:0 },\r\n     *         to: { height: 200 }\r\n     *       });\r\n     *     }\r\n     *   }\r\n     * }]);\r\n     * ```\r\n     *\r\n     * Now we can fill in the rest via our transition CSS code:\r\n     *\r\n     * ```css\r\n     * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\r\n     * .slide.ng-enter { transition:0.5s linear all; }\r\n     *\r\n     * /&#42; this extra CSS class will be absorbed into the transition\r\n     * since the $animateCss code is adding the class &#42;/\r\n     * .maroon-setting { background:red; }\r\n     * ```\r\n     *\r\n     * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\r\n     *\r\n     * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\r\n     *\r\n     * ## Animation Anchoring (via `ng-animate-ref`)\r\n     *\r\n     * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\r\n     * structural areas of an application (like views) by pairing up elements using an attribute\r\n     * called `ng-animate-ref`.\r\n     *\r\n     * Let's say for example we have two views that are managed by `ng-view` and we want to show\r\n     * that there is a relationship between two components situated in within these views. By using the\r\n     * `ng-animate-ref` attribute we can identify that the two components are paired together and we\r\n     * can then attach an animation, which is triggered when the view changes.\r\n     *\r\n     * Say for example we have the following template code:\r\n     *\r\n     * ```html\r\n     * <!-- index.html -->\r\n     * <div ng-view class=\"view-animation\">\r\n     * </div>\r\n     *\r\n     * <!-- home.html -->\r\n     * <a href=\"#/banner-page\">\r\n     *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\r\n     * </a>\r\n     *\r\n     * <!-- banner-page.html -->\r\n     * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\r\n     * ```\r\n     *\r\n     * Now, when the view changes (once the link is clicked), ngAnimate will examine the\r\n     * HTML contents to see if there is a match reference between any components in the view\r\n     * that is leaving and the view that is entering. It will scan both the view which is being\r\n     * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\r\n     * contain a matching ref value.\r\n     *\r\n     * The two images match since they share the same ref value. ngAnimate will now create a\r\n     * transport element (which is a clone of the first image element) and it will then attempt\r\n     * to animate to the position of the second image element in the next view. For the animation to\r\n     * work a special CSS class called `ng-anchor` will be added to the transported element.\r\n     *\r\n     * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\r\n     * ngAnimate will handle the entire transition for us as well as the addition and removal of\r\n     * any changes of CSS classes between the elements:\r\n     *\r\n     * ```css\r\n     * .banner.ng-anchor {\r\n     *   /&#42; this animation will last for 1 second since there are\r\n     *          two phases to the animation (an `in` and an `out` phase) &#42;/\r\n     *   transition:0.5s linear all;\r\n     * }\r\n     * ```\r\n     *\r\n     * We also **must** include animations for the views that are being entered and removed\r\n     * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\r\n     *\r\n     * ```css\r\n     * .view-animation.ng-enter, .view-animation.ng-leave {\r\n     *   transition:0.5s linear all;\r\n     *   position:fixed;\r\n     *   left:0;\r\n     *   top:0;\r\n     *   width:100%;\r\n     * }\r\n     * .view-animation.ng-enter {\r\n     *   transform:translateX(100%);\r\n     * }\r\n     * .view-animation.ng-leave,\r\n     * .view-animation.ng-enter.ng-enter-active {\r\n     *   transform:translateX(0%);\r\n     * }\r\n     * .view-animation.ng-leave.ng-leave-active {\r\n     *   transform:translateX(-100%);\r\n     * }\r\n     * ```\r\n     *\r\n     * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\r\n     * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\r\n     * from its origin. Once that animation is over then the `in` stage occurs which animates the\r\n     * element to its destination. The reason why there are two animations is to give enough time\r\n     * for the enter animation on the new element to be ready.\r\n     *\r\n     * The example above sets up a transition for both the in and out phases, but we can also target the out or\r\n     * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\r\n     *\r\n     * ```css\r\n     * .banner.ng-anchor-out {\r\n     *   transition: 0.5s linear all;\r\n     *\r\n     *   /&#42; the scale will be applied during the out animation,\r\n     *          but will be animated away when the in animation runs &#42;/\r\n     *   transform: scale(1.2);\r\n     * }\r\n     *\r\n     * .banner.ng-anchor-in {\r\n     *   transition: 1s linear all;\r\n     * }\r\n     * ```\r\n     *\r\n     *\r\n     *\r\n     *\r\n     * ### Anchoring Demo\r\n     *\r\n      <example module=\"anchoringExample\"\r\n               name=\"anchoringExample\"\r\n               id=\"anchoringExample\"\r\n               deps=\"angular-animate.js;angular-route.js\"\r\n               animations=\"true\">\r\n        <file name=\"index.html\">\r\n          <a href=\"#!/\">Home</a>\r\n          <hr />\r\n          <div class=\"view-container\">\r\n            <div ng-view class=\"view\"></div>\r\n          </div>\r\n        </file>\r\n        <file name=\"script.js\">\r\n          angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\r\n            .config(['$routeProvider', function($routeProvider) {\r\n              $routeProvider.when('/', {\r\n                templateUrl: 'home.html',\r\n                controller: 'HomeController as home'\r\n              });\r\n              $routeProvider.when('/profile/:id', {\r\n                templateUrl: 'profile.html',\r\n                controller: 'ProfileController as profile'\r\n              });\r\n            }])\r\n            .run(['$rootScope', function($rootScope) {\r\n              $rootScope.records = [\r\n                { id: 1, title: 'Miss Beulah Roob' },\r\n                { id: 2, title: 'Trent Morissette' },\r\n                { id: 3, title: 'Miss Ava Pouros' },\r\n                { id: 4, title: 'Rod Pouros' },\r\n                { id: 5, title: 'Abdul Rice' },\r\n                { id: 6, title: 'Laurie Rutherford Sr.' },\r\n                { id: 7, title: 'Nakia McLaughlin' },\r\n                { id: 8, title: 'Jordon Blanda DVM' },\r\n                { id: 9, title: 'Rhoda Hand' },\r\n                { id: 10, title: 'Alexandrea Sauer' }\r\n              ];\r\n            }])\r\n            .controller('HomeController', [function() {\r\n              //empty\r\n            }])\r\n            .controller('ProfileController', ['$rootScope', '$routeParams',\r\n                function ProfileController($rootScope, $routeParams) {\r\n              var index = parseInt($routeParams.id, 10);\r\n              var record = $rootScope.records[index - 1];\r\n    \r\n              this.title = record.title;\r\n              this.id = record.id;\r\n            }]);\r\n        </file>\r\n        <file name=\"home.html\">\r\n          <h2>Welcome to the home page</h1>\r\n          <p>Please click on an element</p>\r\n          <a class=\"record\"\r\n             ng-href=\"#!/profile/{{ record.id }}\"\r\n             ng-animate-ref=\"{{ record.id }}\"\r\n             ng-repeat=\"record in records\">\r\n            {{ record.title }}\r\n          </a>\r\n        </file>\r\n        <file name=\"profile.html\">\r\n          <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\r\n            {{ profile.title }}\r\n          </div>\r\n        </file>\r\n        <file name=\"animations.css\">\r\n          .record {\r\n            display:block;\r\n            font-size:20px;\r\n          }\r\n          .profile {\r\n            background:black;\r\n            color:white;\r\n            font-size:100px;\r\n          }\r\n          .view-container {\r\n            position:relative;\r\n          }\r\n          .view-container > .view.ng-animate {\r\n            position:absolute;\r\n            top:0;\r\n            left:0;\r\n            width:100%;\r\n            min-height:500px;\r\n          }\r\n          .view.ng-enter, .view.ng-leave,\r\n          .record.ng-anchor {\r\n            transition:0.5s linear all;\r\n          }\r\n          .view.ng-enter {\r\n            transform:translateX(100%);\r\n          }\r\n          .view.ng-enter.ng-enter-active, .view.ng-leave {\r\n            transform:translateX(0%);\r\n          }\r\n          .view.ng-leave.ng-leave-active {\r\n            transform:translateX(-100%);\r\n          }\r\n          .record.ng-anchor-out {\r\n            background:red;\r\n          }\r\n        </file>\r\n      </example>\r\n     *\r\n     * ### How is the element transported?\r\n     *\r\n     * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\r\n     * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\r\n     * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\r\n     * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\r\n     * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\r\n     * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\r\n     * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\r\n     * will become visible since the shim class will be removed.\r\n     *\r\n     * ### How is the morphing handled?\r\n     *\r\n     * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\r\n     * what CSS classes differ between the starting element and the destination element. These different CSS classes\r\n     * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\r\n     * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\r\n     * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\r\n     * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\r\n     * the cloned element is placed inside of root element which is likely close to the body element).\r\n     *\r\n     * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\r\n     *\r\n     *\r\n     * ## Using $animate in your directive code\r\n     *\r\n     * So far we've explored how to feed in animations into an AngularJS application, but how do we trigger animations within our own directives in our application?\r\n     * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\r\n     * imagine we have a greeting box that shows and hides itself when the data changes\r\n     *\r\n     * ```html\r\n     * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\r\n     * ```\r\n     *\r\n     * ```js\r\n     * ngModule.directive('greetingBox', ['$animate', function($animate) {\r\n     *   return function(scope, element, attrs) {\r\n     *     attrs.$observe('active', function(value) {\r\n     *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\r\n     *     });\r\n     *   });\r\n     * }]);\r\n     * ```\r\n     *\r\n     * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\r\n     * in our HTML code then we can trigger a CSS or JS animation to happen.\r\n     *\r\n     * ```css\r\n     * /&#42; normally we would create a CSS class to reference on the element &#42;/\r\n     * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\r\n     * ```\r\n     *\r\n     * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\r\n     * possible be sure to visit the {@link ng.$animate $animate service API page}.\r\n     *\r\n     *\r\n     * ## Callbacks and Promises\r\n     *\r\n     * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\r\n     * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\r\n     * ended by chaining onto the returned promise that animation method returns.\r\n     *\r\n     * ```js\r\n     * // somewhere within the depths of the directive\r\n     * $animate.enter(element, parent).then(function() {\r\n     *   //the animation has completed\r\n     * });\r\n     * ```\r\n     *\r\n     * (Note that earlier versions of AngularJS prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\r\n     * anymore.)\r\n     *\r\n     * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\r\n     * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\r\n     * routing controller to hook into that:\r\n     *\r\n     * ```js\r\n     * ngModule.controller('HomePageController', ['$animate', function($animate) {\r\n     *   $animate.on('enter', ngViewElement, function(element) {\r\n     *     // the animation for this route has completed\r\n     *   }]);\r\n     * }])\r\n     * ```\r\n     *\r\n     * (Note that you will need to trigger a digest within the callback to get AngularJS to notice any scope-related changes.)\r\n     */\r\n\r\n    var copy;\r\n    var extend;\r\n    var forEach;\r\n    var isArray;\r\n    var isDefined;\r\n    var isElement;\r\n    var isFunction;\r\n    var isObject;\r\n    var isString;\r\n    var isUndefined;\r\n    var jqLite;\r\n    var noop;\r\n\r\n    /**\r\n     * @ngdoc service\r\n     * @name $animate\r\n     * @kind object\r\n     *\r\n     * @description\r\n     * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\r\n     *\r\n     * Click here {@link ng.$animate to learn more about animations with `$animate`}.\r\n     */\r\n    angular.module('ngAnimate', [], function initAngularHelpers() {\r\n        // Access helpers from AngularJS core.\r\n        // Do it inside a `config` block to ensure `window.angular` is available.\r\n        noop = angular.noop;\r\n        copy = angular.copy;\r\n        extend = angular.extend;\r\n        jqLite = angular.element;\r\n        forEach = angular.forEach;\r\n        isArray = angular.isArray;\r\n        isString = angular.isString;\r\n        isObject = angular.isObject;\r\n        isUndefined = angular.isUndefined;\r\n        isDefined = angular.isDefined;\r\n        isFunction = angular.isFunction;\r\n        isElement = angular.isElement;\r\n    })\r\n      .info({ angularVersion: '1.7.2' })\r\n      .directive('ngAnimateSwap', ngAnimateSwapDirective)\r\n\r\n      .directive('ngAnimateChildren', $$AnimateChildrenDirective)\r\n      .factory('$$rAFScheduler', $$rAFSchedulerFactory)\r\n\r\n      .provider('$$animateQueue', $$AnimateQueueProvider)\r\n      .provider('$$animation', $$AnimationProvider)\r\n\r\n      .provider('$animateCss', $AnimateCssProvider)\r\n      .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\r\n\r\n      .provider('$$animateJs', $$AnimateJsProvider)\r\n      .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\r\n\r\n\r\n})(window, window.angular);"]}